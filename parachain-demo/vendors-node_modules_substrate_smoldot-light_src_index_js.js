"use strict";
(self["webpackChunk_substrate_parachain_demo"] = self["webpackChunk_substrate_parachain_demo"] || []).push([["vendors-node_modules_substrate_smoldot-light_src_index_js"],{

/***/ "../../node_modules/@substrate/smoldot-light/src/compat-browser.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/src/compat-browser.js ***!
  \*************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "net": function() { return /* binding */ net; },
/* harmony export */   "Worker": function() { return /* binding */ Worker; },
/* harmony export */   "workerOnMessage": function() { return /* binding */ workerOnMessage; },
/* harmony export */   "workerOnError": function() { return /* binding */ workerOnError; },
/* harmony export */   "postMessage": function() { return /* binding */ postMessage; },
/* harmony export */   "setOnMessage": function() { return /* binding */ setOnMessage; }
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Overrides `compat-nodejs.js` when in a browser.

const net = null;
const Worker = typeof window != 'undefined' ? window.Worker : null;
const workerOnMessage = (worker, callback) => { worker.onmessage = (event) => callback(event.data) };
const workerOnError = (worker, callback) => { worker.onerror = callback; };  // TODO: unclear if the parameter of the callback is same as with NodeJS
const postMessage = (msg) => self.postMessage(msg);
const setOnMessage = (callback) => { self.onmessage = (event) => callback(event.data) };


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/src/health.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/src/health.js ***!
  \*****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "healthChecker": function() { return /* binding */ healthChecker; }
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Creates a new health checker.
//
// The role of the health checker is to report to the user the health of a smoldot chain.
//
// In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the
// way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use
// `start()` in order to start the health checks. The `start()` function must be passed a callback called
// when an update to the health of the node is available.
//
// In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function
// of the health checker. The health checker rewrites the `id` of the requests it receives.
//
// When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This
// function intercepts the responses destined to the requests that have been emitted by the health
// checker and returns `null`. If the response doesn't concern the health checker, the response is
// simply returned by the function.
//
// # How it works
//
// The health checker periodically calls the `system_health` JSON-RPC call in order to determine
// the health of the chain.
//
// In addition to this, as long as the health check reports that `isSyncing` is `true`, the
// health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.
// Whenever a new block is notified, a health check is performed immediately in order to determine
// whether `isSyncing` has changed to `false`.
//
// Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to
// `isSyncing: false` is very low.
//
function healthChecker() {
    // `null` if health checker is not started.
    let checker = null;
    let sendJsonRpc = null;

    return {
        setSendJsonRpc: (cb) => {
            sendJsonRpc = cb;
        },

        start: (healthCallback) => {
            if (checker !== null)
                throw new Error("Can't start the health checker multiple times in parallel");
            if (!sendJsonRpc)
                throw new Error("setSendJsonRpc must be called before starting the health checks");

            checker = {
                healthCallback,
                currentHealthCheckId: null,
                currentHealthTimeout: null,
                currentSubunsubRequestId: null,
                currentSubscriptionId: null,
                isSyncing: false,
                nextRequestId: 0,

                sendJsonRpc: function (request) {
                    // Replace the `id` in the request to prefix the request ID with `extern:`.
                    let parsedRequest;
                    try {
                        parsedRequest = JSON.parse(request);
                    } catch (err) {
                        return;
                    };

                    if (parsedRequest.id) {
                        const newId = 'extern:' + JSON.stringify(parsedRequest.id);
                        parsedRequest.id = newId;
                    }

                    sendJsonRpc(JSON.stringify(parsedRequest));
                },

                responsePassThrough: function (jsonRpcResponse) {
                    let parsedResponse;
                    try {
                        parsedResponse = JSON.parse(jsonRpcResponse);
                    } catch (err) {
                        return jsonRpcResponse;
                    };

                    // Check whether response is a response to `system_health`.
                    if (parsedResponse.id && this.currentHealthCheckId == parsedResponse.id) {
                        this.currentHealthCheckId = null;

                        // Check whether query was successful. It is possible for queries to fail for
                        // various reasons, such as the client being overloaded.
                        if (!parsedResponse.result) {
                            this.update();
                            return null;
                        }

                        this.healthCallback(parsedResponse.result);
                        this.isSyncing = parsedResponse.result.isSyncing;
                        this.update();
                        return null;
                    }

                    // Check whether response is a response to the subscription or unsubscription.
                    if (parsedResponse.id && this.currentSubunsubRequestId == parsedResponse.id) {
                        this.currentSubunsubRequestId = null;

                        // Check whether query was successful. It is possible for queries to fail for
                        // various reasons, such as the client being overloaded.
                        if (!parsedResponse.result) {
                            this.update();
                            return null;
                        }

                        if (this.currentSubscriptionId)
                            this.currentSubscriptionId = null;
                        else
                            this.currentSubscriptionId = parsedResponse.result;

                        this.update();
                        return null;
                    }

                    // Check whether response is a notification to a subscription.
                    if (parsedResponse.params && this.currentSubscriptionId &&
                        parsedResponse.params.subscription == this.currentSubscriptionId) {
                        // Note that after a successful subscription, a notification containing
                        // the current best block is always returned. Considering that a
                        // subscription is performed in response to a health check, calling
                        // `startHealthCheck()` here will lead to a second health check.
                        // It might seem redundant to perform two health checks in a quick
                        // succession, but doing so doesn't lead to any problem, and it is
                        // actually possible for the health to have changed in between as the
                        // current best block might have been updated during the subscription
                        // request.
                        this.startHealthCheck();
                        this.update();
                        return null;
                    }

                    // Response doesn't concern us.
                    if (parsedResponse.id) {
                        // Need to remove the `extern:` prefix.
                        if (!parsedResponse.id.startsWith('extern:'))
                            throw new Error('State inconsistency in health checker');
                        const newId = JSON.parse(parsedResponse.id.slice('extern:'.length));
                        parsedResponse.id = newId;
                    }

                    return JSON.stringify(parsedResponse);
                },

                update: function () {
                    if (!this.currentHealthTimeout) {
                        this.currentHealthTimeout = setTimeout(() => {
                            this.currentHealthTimeout = null;
                            this.startHealthCheck();
                        }, 10000);
                    }

                    if (this.isSyncing && !this.currentSubscriptionId && !this.currentSubunsubRequestId)
                        this.startSubscription();
                    if (!this.isSyncing && this.currentSubscriptionId && !this.currentSubunsubRequestId)
                        this.endSubscription();
                },

                startHealthCheck: function () {
                    if (this.currentHealthCheckId)
                        throw new Error('Internal error in health checker');
                    if (this.currentHealthTimeout) {
                        clearTimeout(this.currentHealthTimeout);
                        this.currentHealthTimeout = null;
                    }
                    this.currentHealthCheckId = "health-checker:" + this.nextRequestId;
                    this.nextRequestId += 1;
                    sendJsonRpc(JSON.stringify({
                        jsonrpc: "2.0",
                        id: this.currentHealthCheckId,
                        method: 'system_health',
                        params: [],
                    }));
                },

                startSubscription: function () {
                    if (this.currentSubunsubRequestId || this.currentSubscriptionId)
                        throw new Error('Internal error in health checker');
                    this.currentSubunsubRequestId = "health-checker:" + this.nextRequestId;
                    this.nextRequestId += 1;
                    sendJsonRpc(JSON.stringify({
                        jsonrpc: "2.0",
                        id: this.currentSubunsubRequestId,
                        method: 'chain_subscribeNewHeads',
                        params: [],
                    }));
                },

                endSubscription: function () {
                    if (this.currentSubunsubRequestId || !this.currentSubscriptionId)
                        throw new Error('Internal error in health checker');
                    this.currentSubunsubRequestId = "health-checker:" + this.nextRequestId;
                    this.nextRequestId += 1;
                    sendJsonRpc(JSON.stringify({
                        jsonrpc: "2.0",
                        id: this.currentSubunsubRequestId,
                        method: 'chain_unsubscribeNewHeads',
                        params: [this.currentSubscriptionId],
                    }));
                },

                destroy: function () {
                    if (this.currentHealthTimeout) {
                        clearTimeout(this.currentHealthTimeout);
                        this.currentHealthTimeout = null;
                    }
                }
            };

            checker.startHealthCheck();
        },
        stop: () => {
            if (checker === null)
                return; // Already stopped.
            checker.destroy();
            checker = null;
        },
        sendJsonRpc: (request) => {
            if (!sendJsonRpc)
                throw new Error("setSendJsonRpc must be called before sending requests");
            if (checker === null)
                sendJsonRpc(request);
            else
                checker.sendJsonRpc(request);
        },
        responsePassThrough: (jsonRpcResponse) => {
            if (checker === null)
                return jsonRpcResponse;
            return checker.responsePassThrough(jsonRpcResponse);
        },
    };
}


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/src/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/src/index.js ***!
  \****************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "healthChecker": function() { return /* reexport safe */ _health_js__WEBPACK_IMPORTED_MODULE_1__.healthChecker; },
/* harmony export */   "AlreadyDestroyedError": function() { return /* binding */ AlreadyDestroyedError; },
/* harmony export */   "AddChainError": function() { return /* binding */ AddChainError; },
/* harmony export */   "JsonRpcDisabledError": function() { return /* binding */ JsonRpcDisabledError; },
/* harmony export */   "CrashError": function() { return /* binding */ CrashError; },
/* harmony export */   "start": function() { return /* binding */ start; }
/* harmony export */ });
/* harmony import */ var _compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat-nodejs.js */ "../../node_modules/@substrate/smoldot-light/src/compat-browser.js");
/* harmony import */ var _health_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./health.js */ "../../node_modules/@substrate/smoldot-light/src/health.js");
// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.




class AlreadyDestroyedError extends Error {
}

class AddChainError extends Error {
  constructor(message) {
    super(message);
  }
}

class JsonRpcDisabledError extends Error {
}

class CrashError extends Error {
  constructor(message) {
    super(message);
  }
}

function start(config) {
  config = config || {};

  const logCallback = config.logCallback || ((level, target, message) => {
    if (level <= 1) {
      console.error("[" + target + "]", message);
    } else if (level == 2) {
      console.warn("[" + target + "]", message);
    } else if (level == 3) {
      console.info("[" + target + "]", message);
    } else if (level == 4) {
      console.debug("[" + target + "]", message);
    } else {
      console.trace("[" + target + "]", message);
    }
  });

  // The actual execution of Smoldot is performed in a worker thread.
  //
  // The line of code below (`new Worker(...)`) is designed to hopefully work across all
  // platforms and bundlers. See the README.md for more context.
  const worker = new _compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__.Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("vendors-node_modules_substrate_smoldot-light_src_worker_js"), __webpack_require__.b));
  let workerError = null;

  // Whenever an `addChain` or `removeChain` message is sent to the worker, a corresponding entry
  // is pushed to this array. The worker needs to send back a confirmation, which pops the first
  // element of this array. In the case of `addChain`, additional fields are stored in this array
  // to finish the initialization of the chain.
  let pendingConfirmations = [];

  // For each chain that is currently running, contains the callback to use to send back JSON-RPC
  // responses corresponding to this chain.
  // Entries are instantly removed when the user desires to remove a chain even before the worker
  // has confirmed the removal. Doing so avoids a race condition where the worker sends back a
  // JSON-RPC response even though we've already sent a `removeChain` message to it.
  let chainsJsonRpcCallbacks = new Map();

  // The worker periodically sends a message of kind 'livenessPing' in order to notify that it is
  // still alive.
  // If this liveness ping isn't received for a long time, an error is reported in the logs.
  // The first check is delayed in order to account for the fact that the worker has to perform
  // an expensive initialization step when initializing the Wasm VM.
  let livenessTimeout = null;
  const resetLivenessTimeout = () => {
    if (livenessTimeout !== null)
      clearTimeout(livenessTimeout);
    livenessTimeout = setTimeout(() => {
      livenessTimeout = null;
      console.warn(
        "Smoldot appears unresponsive. Please open an issue at " +
        "https://github.com/paritytech/smoldot/issues. If you have a debugger available, " +
        "please pause execution, generate a stack trace of the thread that isn't the main " +
        "execution thread, and paste it in the issue. Please also include any other log found " +
        "in the console or elsewhere."
      );
    }, 10000);
  };
  setTimeout(() => resetLivenessTimeout(), 15000);

  // The worker can send us messages whose type is identified through a `kind` field.
  (0,_compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__.workerOnMessage)(worker, (message) => {
    if (message.kind == 'jsonrpc') {
      const cb = chainsJsonRpcCallbacks.get(message.chainId);
      if (cb) cb(message.data);

    } else if (message.kind == 'chainAddedOk') {
      const expected = pendingConfirmations.shift();
      let chainId = message.chainId; // Later set to null when the chain is removed.

      if (chainsJsonRpcCallbacks.has(chainId)) // Sanity check.
        throw 'Unexpected reuse of a chain ID';
      chainsJsonRpcCallbacks.set(chainId, expected.jsonRpcCallback);

      // `expected` was pushed by the `addChain` method.
      // Resolve the promise that `addChain` returned to the user.
      expected.resolve({
        sendJsonRpc: (request) => {
          if (workerError)
            throw workerError;
          if (chainId === null)
            throw new AlreadyDestroyedError();
          if (!chainsJsonRpcCallbacks.has(chainId))
            throw new JsonRpcDisabledError();
          worker.postMessage({ ty: 'request', request, chainId });
        },
        remove: () => {
          if (workerError)
            throw workerError;
          if (chainId === null)
            throw new AlreadyDestroyedError();
          pendingConfirmations.push({ ty: 'chainRemoved', chainId });
          worker.postMessage({ ty: 'removeChain', chainId });
          // Because the `removeChain` message is asynchronous, it is possible for a JSON-RPC
          // response concerning that `chainId` to arrive after the `remove` function has
          // returned. We solve that by removing the callback immediately.
          chainsJsonRpcCallbacks.delete(chainId);
          chainId = null;
        },
        // Hacky internal method that later lets us access the `chainId` of this chain for
        // implementation reasons.
        __internal_smoldot_id: () => chainId,
      });

    } else if (message.kind == 'chainAddedErr') {
      const expected = pendingConfirmations.shift();
      // `expected` was pushed by the `addChain` method.
      // Reject the promise that `addChain` returned to the user.
      expected.reject(new AddChainError(message.error));

    } else if (message.kind == 'chainRemoved') {
      pendingConfirmations.shift();

    } else if (message.kind == 'log') {
      logCallback(message.level, message.target, message.message);

    } else if (message.kind == 'livenessPing') {
      resetLivenessTimeout();

    } else {
      console.error('Unknown message type', message);
    }
  });

  (0,_compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__.workerOnError)(worker, (error) => {
    // A worker error should only happen in case of a critical error as the result of a bug
    // somewhere. Consequently, nothing is really in place to cleanly report the error.
    console.error(
      "Smoldot has panicked. This is a bug in smoldot. Please open an issue at " +
      "https://github.com/paritytech/smoldot/issues with the following message:"
    );
    console.error(error);
    workerError = new CrashError(error.toString());

    // Reject all promises returned by `addChain`.
    for (var pending of pendingConfirmations) {
      if (pending.ty == 'chainAdded')
        pending.reject(workerError);
    }
    pendingConfirmations = [];
  });

  // The first message expected by the worker contains the configuration.
  worker.postMessage({
    // Maximum level of log entries sent by the client.
    // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace
    maxLogLevel: config.maxLogLevel || 3,
    forbidTcp: config.forbidTcp,
    forbidWs: config.forbidWs,
    forbidWss: config.forbidWss,
  });

  return {
    addChain: (options) => {
      if (workerError)
        throw workerError;

      let potentialRelayChainsIds = [];
      if (!!options.potentialRelayChains) {
        for (const chain of options.potentialRelayChains) {
          // The content of `options.potentialRelayChains` are supposed to be chains earlier
          // returned by `addChain`. The hacky `__internal_smoldot_id` method lets us obtain the
          // internal ID of these chains.
          const id = chain.__internal_smoldot_id();
          if (id === null) // It is possible for `id` to be null if it has earlier been removed.
            continue;
          potentialRelayChainsIds.push(id);
        }
      }

      // Build a promise that will be resolved or rejected after the chain has been added.
      let chainAddedPromiseResolve;
      let chainAddedPromiseReject;
      const chainAddedPromise = new Promise((resolve, reject) => {
        chainAddedPromiseResolve = resolve;
        chainAddedPromiseReject = reject;
      });

      pendingConfirmations.push({
        ty: 'chainAdded',
        reject: chainAddedPromiseReject,
        resolve: chainAddedPromiseResolve,
        jsonRpcCallback: options.jsonRpcCallback,
      });

      worker.postMessage({
        ty: 'addChain',
        chainSpec: options.chainSpec,
        potentialRelayChains: potentialRelayChainsIds,
        jsonRpcRunning: !!options.jsonRpcCallback,
      });

      return chainAddedPromise;
    },
    terminate: () => {
      worker.terminate();
      if (!workerError)
        workerError = new AlreadyDestroyedError();
    }
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc3Vic3RyYXRlX3Ntb2xkb3QtbGlnaHRfc3JjX2luZGV4X2pzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRU87QUFDQTtBQUNBLGdEQUFnRDtBQUNoRCw4Q0FBOEMsK0JBQStCO0FBQzdFO0FBQ0EscUNBQXFDOzs7Ozs7Ozs7Ozs7Ozs7QUN4QjVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3Vic3RyYXRlL3BhcmFjaGFpbi1kZW1vLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvc3JjL2NvbXBhdC1icm93c2VyLmpzIiwid2VicGFjazovL0BzdWJzdHJhdGUvcGFyYWNoYWluLWRlbW8vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdWJzdHJhdGUvc21vbGRvdC1saWdodC9zcmMvaGVhbHRoLmpzIiwid2VicGFjazovL0BzdWJzdHJhdGUvcGFyYWNoYWluLWRlbW8vLi4vLi4vbm9kZV9tb2R1bGVzL0BzdWJzdHJhdGUvc21vbGRvdC1saWdodC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjEgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuLy8gT3ZlcnJpZGVzIGBjb21wYXQtbm9kZWpzLmpzYCB3aGVuIGluIGEgYnJvd3Nlci5cblxuZXhwb3J0IGNvbnN0IG5ldCA9IG51bGw7XG5leHBvcnQgY29uc3QgV29ya2VyID0gdHlwZW9mIHdpbmRvdyAhPSAndW5kZWZpbmVkJyA/IHdpbmRvdy5Xb3JrZXIgOiBudWxsO1xuZXhwb3J0IGNvbnN0IHdvcmtlck9uTWVzc2FnZSA9ICh3b3JrZXIsIGNhbGxiYWNrKSA9PiB7IHdvcmtlci5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IGNhbGxiYWNrKGV2ZW50LmRhdGEpIH07XG5leHBvcnQgY29uc3Qgd29ya2VyT25FcnJvciA9ICh3b3JrZXIsIGNhbGxiYWNrKSA9PiB7IHdvcmtlci5vbmVycm9yID0gY2FsbGJhY2s7IH07ICAvLyBUT0RPOiB1bmNsZWFyIGlmIHRoZSBwYXJhbWV0ZXIgb2YgdGhlIGNhbGxiYWNrIGlzIHNhbWUgYXMgd2l0aCBOb2RlSlNcbmV4cG9ydCBjb25zdCBwb3N0TWVzc2FnZSA9IChtc2cpID0+IHNlbGYucG9zdE1lc3NhZ2UobXNnKTtcbmV4cG9ydCBjb25zdCBzZXRPbk1lc3NhZ2UgPSAoY2FsbGJhY2spID0+IHsgc2VsZi5vbm1lc3NhZ2UgPSAoZXZlbnQpID0+IGNhbGxiYWNrKGV2ZW50LmRhdGEpIH07XG4iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMSAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcblxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG4vLyBDcmVhdGVzIGEgbmV3IGhlYWx0aCBjaGVja2VyLlxuLy9cbi8vIFRoZSByb2xlIG9mIHRoZSBoZWFsdGggY2hlY2tlciBpcyB0byByZXBvcnQgdG8gdGhlIHVzZXIgdGhlIGhlYWx0aCBvZiBhIHNtb2xkb3QgY2hhaW4uXG4vL1xuLy8gSW4gb3JkZXIgdG8gdXNlIGl0LCBzdGFydCBieSBjcmVhdGluZyBhIGhlYWx0aCBjaGVja2VyLCBhbmQgY2FsbCBgc2V0U2VuZEpzb25ScGNgIHRvIHNldCB0aGVcbi8vIHdheSB0byBzZW5kIGEgSlNPTi1SUEMgcmVxdWVzdCB0byBhIGNoYWluLiBUaGUgaGVhbHRoIGNoZWNrZXIgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdC4gVXNlXG4vLyBgc3RhcnQoKWAgaW4gb3JkZXIgdG8gc3RhcnQgdGhlIGhlYWx0aCBjaGVja3MuIFRoZSBgc3RhcnQoKWAgZnVuY3Rpb24gbXVzdCBiZSBwYXNzZWQgYSBjYWxsYmFjayBjYWxsZWRcbi8vIHdoZW4gYW4gdXBkYXRlIHRvIHRoZSBoZWFsdGggb2YgdGhlIG5vZGUgaXMgYXZhaWxhYmxlLlxuLy9cbi8vIEluIG9yZGVyIHRvIHNlbmQgYSBKU09OLVJQQyByZXF1ZXN0IHRvIHRoZSBjaGFpbiwgeW91ICoqbXVzdCoqIHVzZSB0aGUgYHNlbmRKc29uUnBjYCBmdW5jdGlvblxuLy8gb2YgdGhlIGhlYWx0aCBjaGVja2VyLiBUaGUgaGVhbHRoIGNoZWNrZXIgcmV3cml0ZXMgdGhlIGBpZGAgb2YgdGhlIHJlcXVlc3RzIGl0IHJlY2VpdmVzLlxuLy9cbi8vIFdoZW4gdGhlIGNoYWluIHNlbmQgYSBKU09OLVJQQyByZXNwb25zZSwgaXQgbXVzdCBiZSBwYXNzZWQgdG8gYHJlc3BvbnNlUGFzc1Rocm91Z2goKWAuIFRoaXNcbi8vIGZ1bmN0aW9uIGludGVyY2VwdHMgdGhlIHJlc3BvbnNlcyBkZXN0aW5lZCB0byB0aGUgcmVxdWVzdHMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBieSB0aGUgaGVhbHRoXG4vLyBjaGVja2VyIGFuZCByZXR1cm5zIGBudWxsYC4gSWYgdGhlIHJlc3BvbnNlIGRvZXNuJ3QgY29uY2VybiB0aGUgaGVhbHRoIGNoZWNrZXIsIHRoZSByZXNwb25zZSBpc1xuLy8gc2ltcGx5IHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cbi8vXG4vLyAjIEhvdyBpdCB3b3Jrc1xuLy9cbi8vIFRoZSBoZWFsdGggY2hlY2tlciBwZXJpb2RpY2FsbHkgY2FsbHMgdGhlIGBzeXN0ZW1faGVhbHRoYCBKU09OLVJQQyBjYWxsIGluIG9yZGVyIHRvIGRldGVybWluZVxuLy8gdGhlIGhlYWx0aCBvZiB0aGUgY2hhaW4uXG4vL1xuLy8gSW4gYWRkaXRpb24gdG8gdGhpcywgYXMgbG9uZyBhcyB0aGUgaGVhbHRoIGNoZWNrIHJlcG9ydHMgdGhhdCBgaXNTeW5jaW5nYCBpcyBgdHJ1ZWAsIHRoZVxuLy8gaGVhbHRoIGNoZWNrZXIgYWxzbyBtYWludGFpbnMgYSBzdWJzY3JpcHRpb24gdG8gbmV3IGJlc3QgYmxvY2tzIHVzaW5nIGBjaGFpbl9zdWJzY3JpYmVOZXdIZWFkc2AuXG4vLyBXaGVuZXZlciBhIG5ldyBibG9jayBpcyBub3RpZmllZCwgYSBoZWFsdGggY2hlY2sgaXMgcGVyZm9ybWVkIGltbWVkaWF0ZWx5IGluIG9yZGVyIHRvIGRldGVybWluZVxuLy8gd2hldGhlciBgaXNTeW5jaW5nYCBoYXMgY2hhbmdlZCB0byBgZmFsc2VgLlxuLy9cbi8vIFRoYW5rcyB0byB0aGlzIHN1YnNjcmlwdGlvbiwgdGhlIGxhdGVuY3kgb2YgdGhlIHJlcG9ydCBvZiB0aGUgc3dpdGNoIGZyb20gYGlzU3luY2luZzogdHJ1ZWAgdG9cbi8vIGBpc1N5bmNpbmc6IGZhbHNlYCBpcyB2ZXJ5IGxvdy5cbi8vXG5leHBvcnQgZnVuY3Rpb24gaGVhbHRoQ2hlY2tlcigpIHtcbiAgICAvLyBgbnVsbGAgaWYgaGVhbHRoIGNoZWNrZXIgaXMgbm90IHN0YXJ0ZWQuXG4gICAgbGV0IGNoZWNrZXIgPSBudWxsO1xuICAgIGxldCBzZW5kSnNvblJwYyA9IG51bGw7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRTZW5kSnNvblJwYzogKGNiKSA9PiB7XG4gICAgICAgICAgICBzZW5kSnNvblJwYyA9IGNiO1xuICAgICAgICB9LFxuXG4gICAgICAgIHN0YXJ0OiAoaGVhbHRoQ2FsbGJhY2spID0+IHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyICE9PSBudWxsKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHN0YXJ0IHRoZSBoZWFsdGggY2hlY2tlciBtdWx0aXBsZSB0aW1lcyBpbiBwYXJhbGxlbFwiKTtcbiAgICAgICAgICAgIGlmICghc2VuZEpzb25ScGMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0U2VuZEpzb25ScGMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHN0YXJ0aW5nIHRoZSBoZWFsdGggY2hlY2tzXCIpO1xuXG4gICAgICAgICAgICBjaGVja2VyID0ge1xuICAgICAgICAgICAgICAgIGhlYWx0aENhbGxiYWNrLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIZWFsdGhDaGVja0lkOiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRIZWFsdGhUaW1lb3V0OiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZDogbnVsbCxcbiAgICAgICAgICAgICAgICBjdXJyZW50U3Vic2NyaXB0aW9uSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgaXNTeW5jaW5nOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBuZXh0UmVxdWVzdElkOiAwLFxuXG4gICAgICAgICAgICAgICAgc2VuZEpzb25ScGM6IGZ1bmN0aW9uIChyZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGBpZGAgaW4gdGhlIHJlcXVlc3QgdG8gcHJlZml4IHRoZSByZXF1ZXN0IElEIHdpdGggYGV4dGVybjpgLlxuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkUmVxdWVzdDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlcXVlc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkUmVxdWVzdC5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSAnZXh0ZXJuOicgKyBKU09OLnN0cmluZ2lmeShwYXJzZWRSZXF1ZXN0LmlkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlcXVlc3QuaWQgPSBuZXdJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHNlbmRKc29uUnBjKEpTT04uc3RyaW5naWZ5KHBhcnNlZFJlcXVlc3QpKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgcmVzcG9uc2VQYXNzVGhyb3VnaDogZnVuY3Rpb24gKGpzb25ScGNSZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgcGFyc2VkUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvblJwY1Jlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ganNvblJwY1Jlc3BvbnNlO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgcmVzcG9uc2UgaXMgYSByZXNwb25zZSB0byBgc3lzdGVtX2hlYWx0aGAuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5pZCAmJiB0aGlzLmN1cnJlbnRIZWFsdGhDaGVja0lkID09IHBhcnNlZFJlc3BvbnNlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhDaGVja0lkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBxdWVyeSB3YXMgc3VjY2Vzc2Z1bC4gSXQgaXMgcG9zc2libGUgZm9yIHF1ZXJpZXMgdG8gZmFpbCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlvdXMgcmVhc29ucywgc3VjaCBhcyB0aGUgY2xpZW50IGJlaW5nIG92ZXJsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGVhbHRoQ2FsbGJhY2socGFyc2VkUmVzcG9uc2UucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaXNTeW5jaW5nID0gcGFyc2VkUmVzcG9uc2UucmVzdWx0LmlzU3luY2luZztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgcmVzcG9uc2UgaXMgYSByZXNwb25zZSB0byB0aGUgc3Vic2NyaXB0aW9uIG9yIHVuc3Vic2NyaXB0aW9uLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkUmVzcG9uc2UuaWQgJiYgdGhpcy5jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgPT0gcGFyc2VkUmVzcG9uc2UuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN1YnVuc3ViUmVxdWVzdElkID0gbnVsbDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBxdWVyeSB3YXMgc3VjY2Vzc2Z1bC4gSXQgaXMgcG9zc2libGUgZm9yIHF1ZXJpZXMgdG8gZmFpbCBmb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhcmlvdXMgcmVhc29ucywgc3VjaCBhcyB0aGUgY2xpZW50IGJlaW5nIG92ZXJsb2FkZWQuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBhcnNlZFJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uSWQgPSBwYXJzZWRSZXNwb25zZS5yZXN1bHQ7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgcmVzcG9uc2UgaXMgYSBub3RpZmljYXRpb24gdG8gYSBzdWJzY3JpcHRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5wYXJhbXMgJiYgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uSWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlLnBhcmFtcy5zdWJzY3JpcHRpb24gPT0gdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBhZnRlciBhIHN1Y2Nlc3NmdWwgc3Vic2NyaXB0aW9uLCBhIG5vdGlmaWNhdGlvbiBjb250YWluaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGUgY3VycmVudCBiZXN0IGJsb2NrIGlzIGFsd2F5cyByZXR1cm5lZC4gQ29uc2lkZXJpbmcgdGhhdCBhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBzdWJzY3JpcHRpb24gaXMgcGVyZm9ybWVkIGluIHJlc3BvbnNlIHRvIGEgaGVhbHRoIGNoZWNrLCBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBgc3RhcnRIZWFsdGhDaGVjaygpYCBoZXJlIHdpbGwgbGVhZCB0byBhIHNlY29uZCBoZWFsdGggY2hlY2suXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBJdCBtaWdodCBzZWVtIHJlZHVuZGFudCB0byBwZXJmb3JtIHR3byBoZWFsdGggY2hlY2tzIGluIGEgcXVpY2tcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1Y2Nlc3Npb24sIGJ1dCBkb2luZyBzbyBkb2Vzbid0IGxlYWQgdG8gYW55IHByb2JsZW0sIGFuZCBpdCBpc1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWN0dWFsbHkgcG9zc2libGUgZm9yIHRoZSBoZWFsdGggdG8gaGF2ZSBjaGFuZ2VkIGluIGJldHdlZW4gYXMgdGhlXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBjdXJyZW50IGJlc3QgYmxvY2sgbWlnaHQgaGF2ZSBiZWVuIHVwZGF0ZWQgZHVyaW5nIHRoZSBzdWJzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcXVlc3QuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SGVhbHRoQ2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc3BvbnNlIGRvZXNuJ3QgY29uY2VybiB1cy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFJlc3BvbnNlLmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZWVkIHRvIHJlbW92ZSB0aGUgYGV4dGVybjpgIHByZWZpeC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmVzcG9uc2UuaWQuc3RhcnRzV2l0aCgnZXh0ZXJuOicpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3RhdGUgaW5jb25zaXN0ZW5jeSBpbiBoZWFsdGggY2hlY2tlcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbmV3SWQgPSBKU09OLnBhcnNlKHBhcnNlZFJlc3BvbnNlLmlkLnNsaWNlKCdleHRlcm46Jy5sZW5ndGgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlLmlkID0gbmV3SWQ7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICB1cGRhdGU6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmN1cnJlbnRIZWFsdGhUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SGVhbHRoVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydEhlYWx0aENoZWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAxMDAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5pc1N5bmNpbmcgJiYgIXRoaXMuY3VycmVudFN1YnNjcmlwdGlvbklkICYmICF0aGlzLmN1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzU3luY2luZyAmJiB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZCAmJiAhdGhpcy5jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVuZFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzdGFydEhlYWx0aENoZWNrOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhDaGVja0lkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciBpbiBoZWFsdGggY2hlY2tlcicpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudEhlYWx0aFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SGVhbHRoVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SGVhbHRoQ2hlY2tJZCA9IFwiaGVhbHRoLWNoZWNrZXI6XCIgKyB0aGlzLm5leHRSZXF1ZXN0SWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFJlcXVlc3RJZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZW5kSnNvblJwYyhKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuY3VycmVudEhlYWx0aENoZWNrSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdzeXN0ZW1faGVhbHRoJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgc3RhcnRTdWJzY3JpcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN1YnVuc3ViUmVxdWVzdElkIHx8IHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciBpbiBoZWFsdGggY2hlY2tlcicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCA9IFwiaGVhbHRoLWNoZWNrZXI6XCIgKyB0aGlzLm5leHRSZXF1ZXN0SWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFJlcXVlc3RJZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZW5kSnNvblJwYyhKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuY3VycmVudFN1YnVuc3ViUmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnY2hhaW5fc3Vic2NyaWJlTmV3SGVhZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBlbmRTdWJzY3JpcHRpb246IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN1YnVuc3ViUmVxdWVzdElkIHx8ICF0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3IgaW4gaGVhbHRoIGNoZWNrZXInKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgPSBcImhlYWx0aC1jaGVja2VyOlwiICsgdGhpcy5uZXh0UmVxdWVzdElkO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHRSZXF1ZXN0SWQgKz0gMTtcbiAgICAgICAgICAgICAgICAgICAgc2VuZEpzb25ScGMoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkOiB0aGlzLmN1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ2NoYWluX3Vuc3Vic2NyaWJlTmV3SGVhZHMnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uSWRdLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmN1cnJlbnRIZWFsdGhUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEhlYWx0aFRpbWVvdXQgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgY2hlY2tlci5zdGFydEhlYWx0aENoZWNrKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHN0b3A6ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChjaGVja2VyID09PSBudWxsKVxuICAgICAgICAgICAgICAgIHJldHVybjsgLy8gQWxyZWFkeSBzdG9wcGVkLlxuICAgICAgICAgICAgY2hlY2tlci5kZXN0cm95KCk7XG4gICAgICAgICAgICBjaGVja2VyID0gbnVsbDtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZEpzb25ScGM6IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgICBpZiAoIXNlbmRKc29uUnBjKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFNlbmRKc29uUnBjIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzXCIpO1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgc2VuZEpzb25ScGMocmVxdWVzdCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgY2hlY2tlci5zZW5kSnNvblJwYyhyZXF1ZXN0KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVzcG9uc2VQYXNzVGhyb3VnaDogKGpzb25ScGNSZXNwb25zZSkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGpzb25ScGNSZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybiBjaGVja2VyLnJlc3BvbnNlUGFzc1Rocm91Z2goanNvblJwY1Jlc3BvbnNlKTtcbiAgICAgICAgfSxcbiAgICB9O1xufVxuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjEgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbi8vIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuLy8gYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2Zcbi8vIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbi8vIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cblxuaW1wb3J0IHsgV29ya2VyLCB3b3JrZXJPbkVycm9yLCB3b3JrZXJPbk1lc3NhZ2UgfSBmcm9tICcuL2NvbXBhdC1ub2RlanMuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9oZWFsdGguanMnO1xuXG5leHBvcnQgY2xhc3MgQWxyZWFkeURlc3Ryb3llZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5leHBvcnQgY2xhc3MgQWRkQ2hhaW5FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBKc29uUnBjRGlzYWJsZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cblxuZXhwb3J0IGNsYXNzIENyYXNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RhcnQoY29uZmlnKSB7XG4gIGNvbmZpZyA9IGNvbmZpZyB8fCB7fTtcblxuICBjb25zdCBsb2dDYWxsYmFjayA9IGNvbmZpZy5sb2dDYWxsYmFjayB8fCAoKGxldmVsLCB0YXJnZXQsIG1lc3NhZ2UpID0+IHtcbiAgICBpZiAobGV2ZWwgPD0gMSkge1xuICAgICAgY29uc29sZS5lcnJvcihcIltcIiArIHRhcmdldCArIFwiXVwiLCBtZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsID09IDIpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltcIiArIHRhcmdldCArIFwiXVwiLCBtZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsID09IDMpIHtcbiAgICAgIGNvbnNvbGUuaW5mbyhcIltcIiArIHRhcmdldCArIFwiXVwiLCBtZXNzYWdlKTtcbiAgICB9IGVsc2UgaWYgKGxldmVsID09IDQpIHtcbiAgICAgIGNvbnNvbGUuZGVidWcoXCJbXCIgKyB0YXJnZXQgKyBcIl1cIiwgbWVzc2FnZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUudHJhY2UoXCJbXCIgKyB0YXJnZXQgKyBcIl1cIiwgbWVzc2FnZSk7XG4gICAgfVxuICB9KTtcblxuICAvLyBUaGUgYWN0dWFsIGV4ZWN1dGlvbiBvZiBTbW9sZG90IGlzIHBlcmZvcm1lZCBpbiBhIHdvcmtlciB0aHJlYWQuXG4gIC8vXG4gIC8vIFRoZSBsaW5lIG9mIGNvZGUgYmVsb3cgKGBuZXcgV29ya2VyKC4uLilgKSBpcyBkZXNpZ25lZCB0byBob3BlZnVsbHkgd29yayBhY3Jvc3MgYWxsXG4gIC8vIHBsYXRmb3JtcyBhbmQgYnVuZGxlcnMuIFNlZSB0aGUgUkVBRE1FLm1kIGZvciBtb3JlIGNvbnRleHQuXG4gIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIobmV3IFVSTCgnLi93b3JrZXIuanMnLCBpbXBvcnQubWV0YS51cmwpKTtcbiAgbGV0IHdvcmtlckVycm9yID0gbnVsbDtcblxuICAvLyBXaGVuZXZlciBhbiBgYWRkQ2hhaW5gIG9yIGByZW1vdmVDaGFpbmAgbWVzc2FnZSBpcyBzZW50IHRvIHRoZSB3b3JrZXIsIGEgY29ycmVzcG9uZGluZyBlbnRyeVxuICAvLyBpcyBwdXNoZWQgdG8gdGhpcyBhcnJheS4gVGhlIHdvcmtlciBuZWVkcyB0byBzZW5kIGJhY2sgYSBjb25maXJtYXRpb24sIHdoaWNoIHBvcHMgdGhlIGZpcnN0XG4gIC8vIGVsZW1lbnQgb2YgdGhpcyBhcnJheS4gSW4gdGhlIGNhc2Ugb2YgYGFkZENoYWluYCwgYWRkaXRpb25hbCBmaWVsZHMgYXJlIHN0b3JlZCBpbiB0aGlzIGFycmF5XG4gIC8vIHRvIGZpbmlzaCB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGNoYWluLlxuICBsZXQgcGVuZGluZ0NvbmZpcm1hdGlvbnMgPSBbXTtcblxuICAvLyBGb3IgZWFjaCBjaGFpbiB0aGF0IGlzIGN1cnJlbnRseSBydW5uaW5nLCBjb250YWlucyB0aGUgY2FsbGJhY2sgdG8gdXNlIHRvIHNlbmQgYmFjayBKU09OLVJQQ1xuICAvLyByZXNwb25zZXMgY29ycmVzcG9uZGluZyB0byB0aGlzIGNoYWluLlxuICAvLyBFbnRyaWVzIGFyZSBpbnN0YW50bHkgcmVtb3ZlZCB3aGVuIHRoZSB1c2VyIGRlc2lyZXMgdG8gcmVtb3ZlIGEgY2hhaW4gZXZlbiBiZWZvcmUgdGhlIHdvcmtlclxuICAvLyBoYXMgY29uZmlybWVkIHRoZSByZW1vdmFsLiBEb2luZyBzbyBhdm9pZHMgYSByYWNlIGNvbmRpdGlvbiB3aGVyZSB0aGUgd29ya2VyIHNlbmRzIGJhY2sgYVxuICAvLyBKU09OLVJQQyByZXNwb25zZSBldmVuIHRob3VnaCB3ZSd2ZSBhbHJlYWR5IHNlbnQgYSBgcmVtb3ZlQ2hhaW5gIG1lc3NhZ2UgdG8gaXQuXG4gIGxldCBjaGFpbnNKc29uUnBjQ2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuXG4gIC8vIFRoZSB3b3JrZXIgcGVyaW9kaWNhbGx5IHNlbmRzIGEgbWVzc2FnZSBvZiBraW5kICdsaXZlbmVzc1BpbmcnIGluIG9yZGVyIHRvIG5vdGlmeSB0aGF0IGl0IGlzXG4gIC8vIHN0aWxsIGFsaXZlLlxuICAvLyBJZiB0aGlzIGxpdmVuZXNzIHBpbmcgaXNuJ3QgcmVjZWl2ZWQgZm9yIGEgbG9uZyB0aW1lLCBhbiBlcnJvciBpcyByZXBvcnRlZCBpbiB0aGUgbG9ncy5cbiAgLy8gVGhlIGZpcnN0IGNoZWNrIGlzIGRlbGF5ZWQgaW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhlIGZhY3QgdGhhdCB0aGUgd29ya2VyIGhhcyB0byBwZXJmb3JtXG4gIC8vIGFuIGV4cGVuc2l2ZSBpbml0aWFsaXphdGlvbiBzdGVwIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBXYXNtIFZNLlxuICBsZXQgbGl2ZW5lc3NUaW1lb3V0ID0gbnVsbDtcbiAgY29uc3QgcmVzZXRMaXZlbmVzc1RpbWVvdXQgPSAoKSA9PiB7XG4gICAgaWYgKGxpdmVuZXNzVGltZW91dCAhPT0gbnVsbClcbiAgICAgIGNsZWFyVGltZW91dChsaXZlbmVzc1RpbWVvdXQpO1xuICAgIGxpdmVuZXNzVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgbGl2ZW5lc3NUaW1lb3V0ID0gbnVsbDtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgXCJTbW9sZG90IGFwcGVhcnMgdW5yZXNwb25zaXZlLiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBcIiArXG4gICAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvc21vbGRvdC9pc3N1ZXMuIElmIHlvdSBoYXZlIGEgZGVidWdnZXIgYXZhaWxhYmxlLCBcIiArXG4gICAgICAgIFwicGxlYXNlIHBhdXNlIGV4ZWN1dGlvbiwgZ2VuZXJhdGUgYSBzdGFjayB0cmFjZSBvZiB0aGUgdGhyZWFkIHRoYXQgaXNuJ3QgdGhlIG1haW4gXCIgK1xuICAgICAgICBcImV4ZWN1dGlvbiB0aHJlYWQsIGFuZCBwYXN0ZSBpdCBpbiB0aGUgaXNzdWUuIFBsZWFzZSBhbHNvIGluY2x1ZGUgYW55IG90aGVyIGxvZyBmb3VuZCBcIiArXG4gICAgICAgIFwiaW4gdGhlIGNvbnNvbGUgb3IgZWxzZXdoZXJlLlwiXG4gICAgICApO1xuICAgIH0sIDEwMDAwKTtcbiAgfTtcbiAgc2V0VGltZW91dCgoKSA9PiByZXNldExpdmVuZXNzVGltZW91dCgpLCAxNTAwMCk7XG5cbiAgLy8gVGhlIHdvcmtlciBjYW4gc2VuZCB1cyBtZXNzYWdlcyB3aG9zZSB0eXBlIGlzIGlkZW50aWZpZWQgdGhyb3VnaCBhIGBraW5kYCBmaWVsZC5cbiAgd29ya2VyT25NZXNzYWdlKHdvcmtlciwgKG1lc3NhZ2UpID0+IHtcbiAgICBpZiAobWVzc2FnZS5raW5kID09ICdqc29ucnBjJykge1xuICAgICAgY29uc3QgY2IgPSBjaGFpbnNKc29uUnBjQ2FsbGJhY2tzLmdldChtZXNzYWdlLmNoYWluSWQpO1xuICAgICAgaWYgKGNiKSBjYihtZXNzYWdlLmRhdGEpO1xuXG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLmtpbmQgPT0gJ2NoYWluQWRkZWRPaycpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkID0gcGVuZGluZ0NvbmZpcm1hdGlvbnMuc2hpZnQoKTtcbiAgICAgIGxldCBjaGFpbklkID0gbWVzc2FnZS5jaGFpbklkOyAvLyBMYXRlciBzZXQgdG8gbnVsbCB3aGVuIHRoZSBjaGFpbiBpcyByZW1vdmVkLlxuXG4gICAgICBpZiAoY2hhaW5zSnNvblJwY0NhbGxiYWNrcy5oYXMoY2hhaW5JZCkpIC8vIFNhbml0eSBjaGVjay5cbiAgICAgICAgdGhyb3cgJ1VuZXhwZWN0ZWQgcmV1c2Ugb2YgYSBjaGFpbiBJRCc7XG4gICAgICBjaGFpbnNKc29uUnBjQ2FsbGJhY2tzLnNldChjaGFpbklkLCBleHBlY3RlZC5qc29uUnBjQ2FsbGJhY2spO1xuXG4gICAgICAvLyBgZXhwZWN0ZWRgIHdhcyBwdXNoZWQgYnkgdGhlIGBhZGRDaGFpbmAgbWV0aG9kLlxuICAgICAgLy8gUmVzb2x2ZSB0aGUgcHJvbWlzZSB0aGF0IGBhZGRDaGFpbmAgcmV0dXJuZWQgdG8gdGhlIHVzZXIuXG4gICAgICBleHBlY3RlZC5yZXNvbHZlKHtcbiAgICAgICAgc2VuZEpzb25ScGM6IChyZXF1ZXN0KSA9PiB7XG4gICAgICAgICAgaWYgKHdvcmtlckVycm9yKVxuICAgICAgICAgICAgdGhyb3cgd29ya2VyRXJyb3I7XG4gICAgICAgICAgaWYgKGNoYWluSWQgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCk7XG4gICAgICAgICAgaWYgKCFjaGFpbnNKc29uUnBjQ2FsbGJhY2tzLmhhcyhjaGFpbklkKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBKc29uUnBjRGlzYWJsZWRFcnJvcigpO1xuICAgICAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7IHR5OiAncmVxdWVzdCcsIHJlcXVlc3QsIGNoYWluSWQgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogKCkgPT4ge1xuICAgICAgICAgIGlmICh3b3JrZXJFcnJvcilcbiAgICAgICAgICAgIHRocm93IHdvcmtlckVycm9yO1xuICAgICAgICAgIGlmIChjaGFpbklkID09PSBudWxsKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEFscmVhZHlEZXN0cm95ZWRFcnJvcigpO1xuICAgICAgICAgIHBlbmRpbmdDb25maXJtYXRpb25zLnB1c2goeyB0eTogJ2NoYWluUmVtb3ZlZCcsIGNoYWluSWQgfSk7XG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHk6ICdyZW1vdmVDaGFpbicsIGNoYWluSWQgfSk7XG4gICAgICAgICAgLy8gQmVjYXVzZSB0aGUgYHJlbW92ZUNoYWluYCBtZXNzYWdlIGlzIGFzeW5jaHJvbm91cywgaXQgaXMgcG9zc2libGUgZm9yIGEgSlNPTi1SUENcbiAgICAgICAgICAvLyByZXNwb25zZSBjb25jZXJuaW5nIHRoYXQgYGNoYWluSWRgIHRvIGFycml2ZSBhZnRlciB0aGUgYHJlbW92ZWAgZnVuY3Rpb24gaGFzXG4gICAgICAgICAgLy8gcmV0dXJuZWQuIFdlIHNvbHZlIHRoYXQgYnkgcmVtb3ZpbmcgdGhlIGNhbGxiYWNrIGltbWVkaWF0ZWx5LlxuICAgICAgICAgIGNoYWluc0pzb25ScGNDYWxsYmFja3MuZGVsZXRlKGNoYWluSWQpO1xuICAgICAgICAgIGNoYWluSWQgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICAvLyBIYWNreSBpbnRlcm5hbCBtZXRob2QgdGhhdCBsYXRlciBsZXRzIHVzIGFjY2VzcyB0aGUgYGNoYWluSWRgIG9mIHRoaXMgY2hhaW4gZm9yXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIHJlYXNvbnMuXG4gICAgICAgIF9faW50ZXJuYWxfc21vbGRvdF9pZDogKCkgPT4gY2hhaW5JZCxcbiAgICAgIH0pO1xuXG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLmtpbmQgPT0gJ2NoYWluQWRkZWRFcnInKSB7XG4gICAgICBjb25zdCBleHBlY3RlZCA9IHBlbmRpbmdDb25maXJtYXRpb25zLnNoaWZ0KCk7XG4gICAgICAvLyBgZXhwZWN0ZWRgIHdhcyBwdXNoZWQgYnkgdGhlIGBhZGRDaGFpbmAgbWV0aG9kLlxuICAgICAgLy8gUmVqZWN0IHRoZSBwcm9taXNlIHRoYXQgYGFkZENoYWluYCByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAgICAgIGV4cGVjdGVkLnJlamVjdChuZXcgQWRkQ2hhaW5FcnJvcihtZXNzYWdlLmVycm9yKSk7XG5cbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uua2luZCA9PSAnY2hhaW5SZW1vdmVkJykge1xuICAgICAgcGVuZGluZ0NvbmZpcm1hdGlvbnMuc2hpZnQoKTtcblxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5raW5kID09ICdsb2cnKSB7XG4gICAgICBsb2dDYWxsYmFjayhtZXNzYWdlLmxldmVsLCBtZXNzYWdlLnRhcmdldCwgbWVzc2FnZS5tZXNzYWdlKTtcblxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5raW5kID09ICdsaXZlbmVzc1BpbmcnKSB7XG4gICAgICByZXNldExpdmVuZXNzVGltZW91dCgpO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ1Vua25vd24gbWVzc2FnZSB0eXBlJywgbWVzc2FnZSk7XG4gICAgfVxuICB9KTtcblxuICB3b3JrZXJPbkVycm9yKHdvcmtlciwgKGVycm9yKSA9PiB7XG4gICAgLy8gQSB3b3JrZXIgZXJyb3Igc2hvdWxkIG9ubHkgaGFwcGVuIGluIGNhc2Ugb2YgYSBjcml0aWNhbCBlcnJvciBhcyB0aGUgcmVzdWx0IG9mIGEgYnVnXG4gICAgLy8gc29tZXdoZXJlLiBDb25zZXF1ZW50bHksIG5vdGhpbmcgaXMgcmVhbGx5IGluIHBsYWNlIHRvIGNsZWFubHkgcmVwb3J0IHRoZSBlcnJvci5cbiAgICBjb25zb2xlLmVycm9yKFxuICAgICAgXCJTbW9sZG90IGhhcyBwYW5pY2tlZC4gVGhpcyBpcyBhIGJ1ZyBpbiBzbW9sZG90LiBQbGVhc2Ugb3BlbiBhbiBpc3N1ZSBhdCBcIiArXG4gICAgICBcImh0dHBzOi8vZ2l0aHViLmNvbS9wYXJpdHl0ZWNoL3Ntb2xkb3QvaXNzdWVzIHdpdGggdGhlIGZvbGxvd2luZyBtZXNzYWdlOlwiXG4gICAgKTtcbiAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB3b3JrZXJFcnJvciA9IG5ldyBDcmFzaEVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuXG4gICAgLy8gUmVqZWN0IGFsbCBwcm9taXNlcyByZXR1cm5lZCBieSBgYWRkQ2hhaW5gLlxuICAgIGZvciAodmFyIHBlbmRpbmcgb2YgcGVuZGluZ0NvbmZpcm1hdGlvbnMpIHtcbiAgICAgIGlmIChwZW5kaW5nLnR5ID09ICdjaGFpbkFkZGVkJylcbiAgICAgICAgcGVuZGluZy5yZWplY3Qod29ya2VyRXJyb3IpO1xuICAgIH1cbiAgICBwZW5kaW5nQ29uZmlybWF0aW9ucyA9IFtdO1xuICB9KTtcblxuICAvLyBUaGUgZmlyc3QgbWVzc2FnZSBleHBlY3RlZCBieSB0aGUgd29ya2VyIGNvbnRhaW5zIHRoZSBjb25maWd1cmF0aW9uLlxuICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgIC8vIE1heGltdW0gbGV2ZWwgb2YgbG9nIGVudHJpZXMgc2VudCBieSB0aGUgY2xpZW50LlxuICAgIC8vIDAgPSBMb2dnaW5nIGRpc2FibGVkLCAxID0gRXJyb3IsIDIgPSBXYXJuLCAzID0gSW5mbywgNCA9IERlYnVnLCA1ID0gVHJhY2VcbiAgICBtYXhMb2dMZXZlbDogY29uZmlnLm1heExvZ0xldmVsIHx8IDMsXG4gICAgZm9yYmlkVGNwOiBjb25maWcuZm9yYmlkVGNwLFxuICAgIGZvcmJpZFdzOiBjb25maWcuZm9yYmlkV3MsXG4gICAgZm9yYmlkV3NzOiBjb25maWcuZm9yYmlkV3NzLFxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIGFkZENoYWluOiAob3B0aW9ucykgPT4ge1xuICAgICAgaWYgKHdvcmtlckVycm9yKVxuICAgICAgICB0aHJvdyB3b3JrZXJFcnJvcjtcblxuICAgICAgbGV0IHBvdGVudGlhbFJlbGF5Q2hhaW5zSWRzID0gW107XG4gICAgICBpZiAoISFvcHRpb25zLnBvdGVudGlhbFJlbGF5Q2hhaW5zKSB7XG4gICAgICAgIGZvciAoY29uc3QgY2hhaW4gb2Ygb3B0aW9ucy5wb3RlbnRpYWxSZWxheUNoYWlucykge1xuICAgICAgICAgIC8vIFRoZSBjb250ZW50IG9mIGBvcHRpb25zLnBvdGVudGlhbFJlbGF5Q2hhaW5zYCBhcmUgc3VwcG9zZWQgdG8gYmUgY2hhaW5zIGVhcmxpZXJcbiAgICAgICAgICAvLyByZXR1cm5lZCBieSBgYWRkQ2hhaW5gLiBUaGUgaGFja3kgYF9faW50ZXJuYWxfc21vbGRvdF9pZGAgbWV0aG9kIGxldHMgdXMgb2J0YWluIHRoZVxuICAgICAgICAgIC8vIGludGVybmFsIElEIG9mIHRoZXNlIGNoYWlucy5cbiAgICAgICAgICBjb25zdCBpZCA9IGNoYWluLl9faW50ZXJuYWxfc21vbGRvdF9pZCgpO1xuICAgICAgICAgIGlmIChpZCA9PT0gbnVsbCkgLy8gSXQgaXMgcG9zc2libGUgZm9yIGBpZGAgdG8gYmUgbnVsbCBpZiBpdCBoYXMgZWFybGllciBiZWVuIHJlbW92ZWQuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICBwb3RlbnRpYWxSZWxheUNoYWluc0lkcy5wdXNoKGlkKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBCdWlsZCBhIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIG9yIHJlamVjdGVkIGFmdGVyIHRoZSBjaGFpbiBoYXMgYmVlbiBhZGRlZC5cbiAgICAgIGxldCBjaGFpbkFkZGVkUHJvbWlzZVJlc29sdmU7XG4gICAgICBsZXQgY2hhaW5BZGRlZFByb21pc2VSZWplY3Q7XG4gICAgICBjb25zdCBjaGFpbkFkZGVkUHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgY2hhaW5BZGRlZFByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgY2hhaW5BZGRlZFByb21pc2VSZWplY3QgPSByZWplY3Q7XG4gICAgICB9KTtcblxuICAgICAgcGVuZGluZ0NvbmZpcm1hdGlvbnMucHVzaCh7XG4gICAgICAgIHR5OiAnY2hhaW5BZGRlZCcsXG4gICAgICAgIHJlamVjdDogY2hhaW5BZGRlZFByb21pc2VSZWplY3QsXG4gICAgICAgIHJlc29sdmU6IGNoYWluQWRkZWRQcm9taXNlUmVzb2x2ZSxcbiAgICAgICAganNvblJwY0NhbGxiYWNrOiBvcHRpb25zLmpzb25ScGNDYWxsYmFjayxcbiAgICAgIH0pO1xuXG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoe1xuICAgICAgICB0eTogJ2FkZENoYWluJyxcbiAgICAgICAgY2hhaW5TcGVjOiBvcHRpb25zLmNoYWluU3BlYyxcbiAgICAgICAgcG90ZW50aWFsUmVsYXlDaGFpbnM6IHBvdGVudGlhbFJlbGF5Q2hhaW5zSWRzLFxuICAgICAgICBqc29uUnBjUnVubmluZzogISFvcHRpb25zLmpzb25ScGNDYWxsYmFjayxcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gY2hhaW5BZGRlZFByb21pc2U7XG4gICAgfSxcbiAgICB0ZXJtaW5hdGU6ICgpID0+IHtcbiAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgIGlmICghd29ya2VyRXJyb3IpXG4gICAgICAgIHdvcmtlckVycm9yID0gbmV3IEFscmVhZHlEZXN0cm95ZWRFcnJvcigpO1xuICAgIH1cbiAgfVxufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9