"use strict";
(self["webpackChunk_substrate_burnr"] = self["webpackChunk_substrate_burnr"] || []).push([["vendors-node_modules_substrate_smoldot-light_dist_index_js"],{

/***/ "../../node_modules/@substrate/smoldot-light/dist/client.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/dist/client.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "AddChainError": () => (/* binding */ AddChainError),
/* harmony export */   "AlreadyDestroyedError": () => (/* binding */ AlreadyDestroyedError),
/* harmony export */   "JsonRpcDisabledError": () => (/* binding */ JsonRpcDisabledError),
/* harmony export */   "CrashError": () => (/* binding */ CrashError),
/* harmony export */   "start": () => (/* binding */ start)
/* harmony export */ });
/* harmony import */ var _compat_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat/index.js */ "../../node_modules/@substrate/smoldot-light/dist/compat/index-browser-overwrite.js");
/* harmony import */ var _worker_spawn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./worker/spawn.js */ "../../node_modules/@substrate/smoldot-light/dist/worker/spawn-browser-overwrite.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


/**
 * Thrown in case of a problem when initializing the chain.
 */
class AddChainError extends Error {
    constructor(message) {
        super(message);
    }
}
/**
 * Thrown in case the API user tries to use a chain or client that has already been destroyed.
 */
class AlreadyDestroyedError extends Error {
}
/**
 * Thrown when trying to send a JSON-RPC message to a chain whose JSON-RPC system hasn't been
 * enabled.
 */
class JsonRpcDisabledError extends Error {
}
/**
 * Thrown in case the underlying client encounters an unexpected crash.
 *
 * This is always an internal bug in smoldot and is never supposed to happen.
 */
class CrashError extends Error {
    constructor(message) {
        super(message);
    }
}
/**
 * Initializes a new client. This is a pre-requisite to connecting to a blockchain.
 *
 * Can never fail.
 *
 * @param options Configuration of the client. Defaults to `{}`.
 */
function start(options) {
    options = options || {};
    const logCallback = options.logCallback || ((level, target, message) => {
        // The first parameter of the methods of `console` has some printf-like substitution
        // capabilities. We don't really need to use this, but not using it means that the logs might
        // not get printed correctly if they contain `%`.
        if (level <= 1) {
            console.error("[%s] %s", target, message);
        }
        else if (level == 2) {
            console.warn("[%s] %s", target, message);
        }
        else if (level == 3) {
            console.info("[%s] %s", target, message);
        }
        else if (level == 4) {
            console.debug("[%s] %s", target, message);
        }
        else {
            console.trace("[%s] %s", target, message);
        }
    });
    // The actual execution of Smoldot is performed in a worker thread.
    // Because this specific line of code is a bit sensitive, it is done in a separate file.
    const worker = (0,_worker_spawn_js__WEBPACK_IMPORTED_MODULE_1__["default"])();
    let workerError = null;
    // Whenever an `addChain` or `removeChain` message is sent to the worker, a corresponding entry
    // is pushed to this array. The worker needs to send back a confirmation, which pops the first
    // element of this array. In the case of `addChain`, additional fields are stored in this array
    // to finish the initialization of the chain.
    let pendingConfirmations = [];
    // Contains the information of each chain that is currently.
    // Entries are instantly removed when the user desires to remove a chain even before the worker
    // has confirmed the removal. Doing so avoids a race condition where the worker sends back a
    // database content or a JSON-RPC response/notification even though we've already sent a
    // `removeChain` message to it.
    //
    // This map is also used in general as a way to check whether a chain still exists.
    let chains = new Map();
    // For each chain object returned by `addChain`, the associated internal chain id.
    //
    // Immediately cleared when `remove()` is called on a chain.
    let chainIds = new WeakMap();
    // The worker periodically reports the name of the task it is currently in. This makes it
    // possible, when the worker is frozen, to know which task it was in when frozen.
    const workerCurrentTask = { name: null };
    // The worker periodically sends a message of kind 'livenessPing' in order to notify that it is
    // still alive.
    // If this liveness ping isn't received for a long time, an error is reported in the logs.
    // The first check is delayed in order to account for the fact that the worker has to perform
    // an expensive initialization step when initializing the Wasm VM.
    let livenessTimeout = null;
    const resetLivenessTimeout = () => {
        if (livenessTimeout !== null)
            globalThis.clearTimeout(livenessTimeout);
        livenessTimeout = globalThis.setTimeout(() => {
            livenessTimeout = null;
            console.warn("Smoldot appears unresponsive" +
                (workerCurrentTask.name ? (" while executing task `" + workerCurrentTask.name + "`") : "") +
                ". Please open an issue at https://github.com/paritytech/smoldot/issues. If you have a " +
                "debugger available, please pause execution, generate a stack trace of the thread " +
                "that isn't the main execution thread, and paste it in the issue. Please also include " +
                "any other log found in the console or elsewhere.");
        }, 10000);
    };
    globalThis.setTimeout(() => resetLivenessTimeout(), 15000);
    // The worker can send us messages whose type is identified through a `kind` field.
    (0,_compat_index_js__WEBPACK_IMPORTED_MODULE_0__.workerOnMessage)(worker, (message) => {
        switch (message.kind) {
            case 'jsonrpc': {
                const cb = chains.get(message.chainId)?.jsonRpcCallback;
                if (cb)
                    cb(message.data);
                break;
            }
            case 'chainAddedOk': {
                const expected = pendingConfirmations.shift();
                const chainId = message.chainId;
                if (chains.has(chainId)) // Sanity check.
                    throw 'Unexpected reuse of a chain ID';
                chains.set(chainId, {
                    jsonRpcCallback: expected.jsonRpcCallback,
                    databasePromises: new Array()
                });
                // `expected` was pushed by the `addChain` method.
                // Resolve the promise that `addChain` returned to the user.
                const newChain = {
                    sendJsonRpc: (request) => {
                        if (workerError)
                            throw workerError;
                        if (!chains.has(chainId))
                            throw new AlreadyDestroyedError();
                        if (!(chains.get(chainId)?.jsonRpcCallback))
                            throw new JsonRpcDisabledError();
                        if (request.length >= 8 * 1024 * 1024)
                            return;
                        postMessage(worker, { ty: 'request', request, chainId });
                    },
                    databaseContent: (maxUtf8BytesSize) => {
                        if (workerError)
                            return Promise.reject(workerError);
                        const databaseContentPromises = chains.get(chainId)?.databasePromises;
                        if (!databaseContentPromises)
                            return Promise.reject(new AlreadyDestroyedError());
                        const promise = new Promise((resolve, reject) => {
                            databaseContentPromises.push({ resolve, reject });
                        });
                        const twoPower32 = (1 << 30) * 4; // `1 << 31` and `1 << 32` in JavaScript don't give the value that you expect.
                        const maxSize = maxUtf8BytesSize || (twoPower32 - 1);
                        const cappedMaxSize = (maxSize >= twoPower32) ? (twoPower32 - 1) : maxSize;
                        postMessage(worker, { ty: 'databaseContent', chainId, maxUtf8BytesSize: cappedMaxSize });
                        return promise;
                    },
                    remove: () => {
                        if (workerError)
                            throw workerError;
                        // Because the `removeChain` message is asynchronous, it is possible for a JSON-RPC
                        // response or database content concerning that `chainId` to arrive after the `remove`
                        // function has returned. We solve that by removing the information immediately.
                        if (!chains.delete(chainId))
                            throw new AlreadyDestroyedError();
                        console.assert(chainIds.has(newChain));
                        chainIds.delete(newChain);
                        postMessage(worker, { ty: 'removeChain', chainId });
                    },
                };
                chainIds.set(newChain, chainId);
                expected.resolve(newChain);
                break;
            }
            case 'chainAddedErr': {
                const expected = pendingConfirmations.shift();
                // `expected` was pushed by the `addChain` method.
                // Reject the promise that `addChain` returned to the user.
                expected.reject(message.error);
                break;
            }
            case 'databaseContent': {
                const promises = chains.get(message.chainId)?.databasePromises;
                if (promises)
                    promises.shift().resolve(message.data);
                break;
            }
            case 'log': {
                logCallback(message.level, message.target, message.message);
                break;
            }
            case 'livenessPing': {
                resetLivenessTimeout();
                break;
            }
            case 'currentTask': {
                workerCurrentTask.name = message.taskName;
                break;
            }
            default: {
                // Exhaustive check.
                const _exhaustiveCheck = message;
                return _exhaustiveCheck;
            }
        }
    });
    (0,_compat_index_js__WEBPACK_IMPORTED_MODULE_0__.workerOnError)(worker, (error) => {
        // A worker error should only happen in case of a critical error as the result of a bug
        // somewhere. Consequently, nothing is really in place to cleanly report the error.
        console.error("Smoldot has panicked" +
            (workerCurrentTask.name ? (" while executing task `" + workerCurrentTask.name + "`") : "") +
            ". This is a bug in smoldot. Please open an issue at " +
            "https://github.com/paritytech/smoldot/issues with the following message:");
        console.error(error);
        workerError = new CrashError(error.toString());
        // Reject all promises returned by `addChain`.
        for (var pending of pendingConfirmations) {
            if (pending.ty == 'chainAdded')
                pending.reject(workerError);
        }
        pendingConfirmations = [];
        // Reject all promises for database contents.
        for (const chain of chains) {
            for (const promise of chain[1].databasePromises) {
                promise.reject(workerError);
            }
        }
        chains.clear();
    });
    // The first message expected by the worker contains the configuration.
    postMessage(worker, {
        // Maximum level of log entries sent by the client.
        // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace
        maxLogLevel: options.maxLogLevel || 3,
        enableCurrentTask: true,
        forbidTcp: options.forbidTcp || false,
        forbidWs: options.forbidWs || false,
        forbidNonLocalWs: options.forbidNonLocalWs || false,
        forbidWss: options.forbidWss || false,
    });
    return {
        addChain: (options) => {
            if (workerError)
                throw workerError;
            let potentialRelayChainsIds = [];
            if (!!options.potentialRelayChains) {
                for (const chain of options.potentialRelayChains) {
                    // The content of `options.potentialRelayChains` are supposed to be chains earlier
                    // returned by `addChain`.
                    const id = chainIds.get(chain);
                    if (id === undefined) // It is possible for `id` to be missing if it has earlier been removed.
                        continue;
                    potentialRelayChainsIds.push(id);
                }
            }
            // Build a promise that will be resolved or rejected after the chain has been added.
            // TODO: because of https://github.com/microsoft/TypeScript/issues/11498 we need to define the callbacks as possibly null, and go through `unknown`
            let chainAddedPromiseResolve;
            let chainAddedPromiseReject;
            const chainAddedPromise = new Promise((resolve, reject) => {
                chainAddedPromiseResolve = resolve;
                chainAddedPromiseReject = reject;
            });
            pendingConfirmations.push({
                ty: 'chainAdded',
                reject: chainAddedPromiseReject,
                resolve: chainAddedPromiseResolve,
                jsonRpcCallback: options.jsonRpcCallback,
            });
            postMessage(worker, {
                ty: 'addChain',
                chainSpec: options.chainSpec,
                databaseContent: typeof options.databaseContent === 'string' ? options.databaseContent : "",
                potentialRelayChains: potentialRelayChainsIds,
                jsonRpcRunning: !!options.jsonRpcCallback,
            });
            return chainAddedPromise;
        },
        terminate: () => {
            if (workerError)
                return Promise.reject(workerError);
            workerError = new AlreadyDestroyedError();
            if (livenessTimeout !== null)
                globalThis.clearTimeout(livenessTimeout);
            return (0,_compat_index_js__WEBPACK_IMPORTED_MODULE_0__.workerTerminate)(worker);
        }
    };
}
// Separate function in order to enforce types.
function postMessage(worker, message) {
    worker.postMessage(message);
}


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/dist/compat/index-browser-overwrite.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/dist/compat/index-browser-overwrite.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "workerOnMessage": () => (/* binding */ workerOnMessage),
/* harmony export */   "workerOnError": () => (/* binding */ workerOnError),
/* harmony export */   "workerTerminate": () => (/* binding */ workerTerminate),
/* harmony export */   "postMessage": () => (/* binding */ postMessage),
/* harmony export */   "setOnMessage": () => (/* binding */ setOnMessage),
/* harmony export */   "performanceNow": () => (/* binding */ performanceNow),
/* harmony export */   "isTcpAvailable": () => (/* binding */ isTcpAvailable),
/* harmony export */   "createConnection": () => (/* binding */ createConnection),
/* harmony export */   "getRandomValues": () => (/* binding */ getRandomValues)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
// Overrides `index.js` when in a browser.
function workerOnMessage(worker, callback) {
    worker.onmessage = (event) => callback(event.data);
}
function workerOnError(worker, callback) {
    // TODO: unclear if the parameter of the callback is same as with NodeJS
    worker.onerror = callback;
}
function workerTerminate(worker) {
    worker.terminate();
    return Promise.resolve();
}
function postMessage(msg) {
    self.postMessage(msg);
}
function setOnMessage(callback) {
    self.onmessage = (event) => callback(event.data);
}
function performanceNow() {
    return performance.now();
}
function isTcpAvailable() {
    return false;
}
function createConnection(_opts, _connectionListener) {
    throw new Error('TCP connections not available');
}
function getRandomValues(buffer) {
    const crypto = globalThis.crypto;
    if (!crypto)
        throw new Error('randomness not available');
    crypto.getRandomValues(buffer);
}


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/dist/health.js":
/*!******************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/dist/health.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "healthChecker": () => (/* binding */ healthChecker)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
var __classPrivateFieldSet = (undefined && undefined.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __classPrivateFieldGet = (undefined && undefined.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _InnerChecker_healthCallback, _InnerChecker_currentHealthCheckId, _InnerChecker_currentHealthTimeout, _InnerChecker_currentSubunsubRequestId, _InnerChecker_currentSubscriptionId, _InnerChecker_requestToSmoldot, _InnerChecker_isSyncing, _InnerChecker_nextRequestId;
/*
 * Creates a new health checker.
 *
 * The role of the health checker is to report to the user the health of a smoldot chain.
 *
 * In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the
 * way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use
 * `start()` in order to start the health checks. The `start()` function must be passed a callback called
 * when an update to the health of the node is available.
 *
 * In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function
 * of the health checker. The health checker rewrites the `id` of the requests it receives.
 *
 * When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This
 * function intercepts the responses destined to the requests that have been emitted by the health
 * checker and returns `null`. If the response doesn't concern the health checker, the response is
 * simply returned by the function.
 *
 * # How it works
 *
 * The health checker periodically calls the `system_health` JSON-RPC call in order to determine
 * the health of the chain.
 *
 * In addition to this, as long as the health check reports that `isSyncing` is `true`, the
 * health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.
 * Whenever a new block is notified, a health check is performed immediately in order to determine
 * whether `isSyncing` has changed to `false`.
 *
 * Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to
 * `isSyncing: false` is very low.
 *
 */
function healthChecker() {
    // `null` if health checker is not started.
    let checker = null;
    let sendJsonRpc = null;
    return {
        setSendJsonRpc: (cb) => {
            sendJsonRpc = cb;
        },
        start: (healthCallback) => {
            if (checker !== null)
                throw new Error("Can't start the health checker multiple times in parallel");
            if (!sendJsonRpc)
                throw new Error("setSendJsonRpc must be called before starting the health checks");
            checker = new InnerChecker(healthCallback, sendJsonRpc);
            checker.startHealthCheck();
        },
        stop: () => {
            if (checker === null)
                return; // Already stopped.
            checker.destroy();
            checker = null;
        },
        sendJsonRpc: (request) => {
            if (!sendJsonRpc)
                throw new Error("setSendJsonRpc must be called before sending requests");
            if (checker === null)
                sendJsonRpc(request);
            else
                checker.sendJsonRpc(request);
        },
        responsePassThrough: (jsonRpcResponse) => {
            if (checker === null)
                return jsonRpcResponse;
            return checker.responsePassThrough(jsonRpcResponse);
        },
    };
}
class InnerChecker {
    constructor(healthCallback, requestToSmoldot) {
        _InnerChecker_healthCallback.set(this, void 0);
        _InnerChecker_currentHealthCheckId.set(this, null);
        _InnerChecker_currentHealthTimeout.set(this, null);
        _InnerChecker_currentSubunsubRequestId.set(this, null);
        _InnerChecker_currentSubscriptionId.set(this, null);
        _InnerChecker_requestToSmoldot.set(this, void 0);
        _InnerChecker_isSyncing.set(this, false);
        _InnerChecker_nextRequestId.set(this, 0);
        __classPrivateFieldSet(this, _InnerChecker_healthCallback, healthCallback, "f");
        __classPrivateFieldSet(this, _InnerChecker_requestToSmoldot, requestToSmoldot, "f");
    }
    sendJsonRpc(request) {
        // Replace the `id` in the request to prefix the request ID with `extern:`.
        let parsedRequest;
        try {
            parsedRequest = JSON.parse(request);
        }
        catch (err) {
            return;
        }
        ;
        if (parsedRequest.id) {
            const newId = 'extern:' + JSON.stringify(parsedRequest.id);
            parsedRequest.id = newId;
        }
        __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, JSON.stringify(parsedRequest));
    }
    responsePassThrough(jsonRpcResponse) {
        let parsedResponse;
        try {
            parsedResponse = JSON.parse(jsonRpcResponse);
        }
        catch (err) {
            return jsonRpcResponse;
        }
        ;
        // Check whether response is a response to `system_health`.
        if (parsedResponse.id && __classPrivateFieldGet(this, _InnerChecker_currentHealthCheckId, "f") == parsedResponse.id) {
            __classPrivateFieldSet(this, _InnerChecker_currentHealthCheckId, null, "f");
            // Check whether query was successful. It is possible for queries to fail for
            // various reasons, such as the client being overloaded.
            if (!parsedResponse.result) {
                this.update();
                return null;
            }
            __classPrivateFieldGet(this, _InnerChecker_healthCallback, "f").call(this, parsedResponse.result);
            __classPrivateFieldSet(this, _InnerChecker_isSyncing, parsedResponse.result.isSyncing, "f");
            this.update();
            return null;
        }
        // Check whether response is a response to the subscription or unsubscription.
        if (parsedResponse.id && __classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f") == parsedResponse.id) {
            __classPrivateFieldSet(this, _InnerChecker_currentSubunsubRequestId, null, "f");
            // Check whether query was successful. It is possible for queries to fail for
            // various reasons, such as the client being overloaded.
            if (!parsedResponse.result) {
                this.update();
                return null;
            }
            if (__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f"))
                __classPrivateFieldSet(this, _InnerChecker_currentSubscriptionId, null, "f");
            else
                __classPrivateFieldSet(this, _InnerChecker_currentSubscriptionId, parsedResponse.result, "f");
            this.update();
            return null;
        }
        // Check whether response is a notification to a subscription.
        if (parsedResponse.params && __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f") &&
            parsedResponse.params.subscription == __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f")) {
            // Note that after a successful subscription, a notification containing
            // the current best block is always returned. Considering that a
            // subscription is performed in response to a health check, calling
            // `startHealthCheck()` here will lead to a second health check.
            // It might seem redundant to perform two health checks in a quick
            // succession, but doing so doesn't lead to any problem, and it is
            // actually possible for the health to have changed in between as the
            // current best block might have been updated during the subscription
            // request.
            this.startHealthCheck();
            this.update();
            return null;
        }
        // Response doesn't concern us.
        if (parsedResponse.id) {
            // Need to remove the `extern:` prefix.
            if (!parsedResponse.id.startsWith('extern:'))
                throw new Error('State inconsistency in health checker');
            const newId = JSON.parse(parsedResponse.id.slice('extern:'.length));
            parsedResponse.id = newId;
        }
        return JSON.stringify(parsedResponse);
    }
    update() {
        if (!__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f")) {
            __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, setTimeout(() => {
                __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, null, "f");
                this.startHealthCheck();
            }, 10000), "f");
        }
        if (__classPrivateFieldGet(this, _InnerChecker_isSyncing, "f") && !__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f") && !__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f"))
            this.startSubscription();
        if (!__classPrivateFieldGet(this, _InnerChecker_isSyncing, "f") && __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f") && !__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f"))
            this.endSubscription();
    }
    startHealthCheck() {
        if (__classPrivateFieldGet(this, _InnerChecker_currentHealthCheckId, "f"))
            throw new Error('Internal error in health checker');
        if (__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f")) {
            clearTimeout(__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f"));
            __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, null, "f");
        }
        __classPrivateFieldSet(this, _InnerChecker_currentHealthCheckId, "health-checker:" + __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f"), "f");
        __classPrivateFieldSet(this, _InnerChecker_nextRequestId, __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f") + 1, "f");
        __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, JSON.stringify({
            jsonrpc: "2.0",
            id: __classPrivateFieldGet(this, _InnerChecker_currentHealthCheckId, "f"),
            method: 'system_health',
            params: [],
        }));
    }
    startSubscription() {
        if (__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f") || __classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f"))
            throw new Error('Internal error in health checker');
        __classPrivateFieldSet(this, _InnerChecker_currentSubunsubRequestId, "health-checker:" + __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f"), "f");
        __classPrivateFieldSet(this, _InnerChecker_nextRequestId, __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f") + 1, "f");
        __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, JSON.stringify({
            jsonrpc: "2.0",
            id: __classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f"),
            method: 'chain_subscribeNewHeads',
            params: [],
        }));
    }
    endSubscription() {
        if (__classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f") || !__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f"))
            throw new Error('Internal error in health checker');
        __classPrivateFieldSet(this, _InnerChecker_currentSubunsubRequestId, "health-checker:" + __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f"), "f");
        __classPrivateFieldSet(this, _InnerChecker_nextRequestId, __classPrivateFieldGet(this, _InnerChecker_nextRequestId, "f") + 1, "f");
        __classPrivateFieldGet(this, _InnerChecker_requestToSmoldot, "f").call(this, JSON.stringify({
            jsonrpc: "2.0",
            id: __classPrivateFieldGet(this, _InnerChecker_currentSubunsubRequestId, "f"),
            method: 'chain_unsubscribeNewHeads',
            params: [__classPrivateFieldGet(this, _InnerChecker_currentSubscriptionId, "f")],
        }));
    }
    destroy() {
        if (__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f")) {
            clearTimeout(__classPrivateFieldGet(this, _InnerChecker_currentHealthTimeout, "f"));
            __classPrivateFieldSet(this, _InnerChecker_currentHealthTimeout, null, "f");
        }
    }
}
_InnerChecker_healthCallback = new WeakMap(), _InnerChecker_currentHealthCheckId = new WeakMap(), _InnerChecker_currentHealthTimeout = new WeakMap(), _InnerChecker_currentSubunsubRequestId = new WeakMap(), _InnerChecker_currentSubscriptionId = new WeakMap(), _InnerChecker_requestToSmoldot = new WeakMap(), _InnerChecker_isSyncing = new WeakMap(), _InnerChecker_nextRequestId = new WeakMap();


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/dist/index.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/dist/index.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "healthChecker": () => (/* reexport safe */ _health_js__WEBPACK_IMPORTED_MODULE_0__.healthChecker),
/* harmony export */   "AddChainError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_1__.AddChainError),
/* harmony export */   "AlreadyDestroyedError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_1__.AlreadyDestroyedError),
/* harmony export */   "CrashError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_1__.CrashError),
/* harmony export */   "JsonRpcDisabledError": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_1__.JsonRpcDisabledError),
/* harmony export */   "start": () => (/* reexport safe */ _client_js__WEBPACK_IMPORTED_MODULE_1__.start)
/* harmony export */ });
/* harmony import */ var _health_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./health.js */ "../../node_modules/@substrate/smoldot-light/dist/health.js");
/* harmony import */ var _client_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./client.js */ "../../node_modules/@substrate/smoldot-light/dist/client.js");
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

 // TODO: precise exports


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/dist/worker/spawn-browser-overwrite.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/dist/worker/spawn-browser-overwrite.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* export default binding */ __WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2022  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.
/* harmony default export */ function __WEBPACK_DEFAULT_EXPORT__() {
    if (!window.Worker)
        throw new Error("Workers not available");
    // The line of code below (`new Worker(...)`) is designed to hopefully work across all
    // platforms and bundlers.
    // Because this line is precisely recognized by bundlers, we extract it to a separate
    // JavaScript file.
    // See also the README.md for more context.
    const worker = new Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("smoldot"), __webpack_require__.b), { name: "smoldot" });
    return worker;
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfc3Vic3RyYXRlX3Ntb2xkb3QtbGlnaHRfZGlzdF9pbmRleF9qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNvRjtBQUN4QztBQUM1QztBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RDtBQUM5RDtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsbUJBQW1CLDREQUFXO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxJQUFJLGlFQUFlO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsaUNBQWlDO0FBQy9FLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxpQkFBaUI7QUFDNUUseUJBQXlCO0FBQ3pCLDBEQUEwRDtBQUMxRDtBQUNBO0FBQ0EsOENBQThDLGlFQUFpRTtBQUMvRztBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyw0QkFBNEI7QUFDMUUscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJLCtEQUFhO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsaUVBQWU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDMVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQzdDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsU0FBSSxJQUFJLFNBQUk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixTQUFJLElBQUksU0FBSTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQzdPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQzRDO0FBQ2hCLENBQUM7Ozs7Ozs7Ozs7Ozs7OztBQ2Q3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQWUsc0NBQVk7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsbUdBQThCLEtBQUssaUJBQWlCO0FBQzFGO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9Ac3Vic3RyYXRlL2J1cm5yLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvZGlzdC9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vQHN1YnN0cmF0ZS9idXJuci8uLi8uLi9ub2RlX21vZHVsZXMvQHN1YnN0cmF0ZS9zbW9sZG90LWxpZ2h0L2Rpc3QvY29tcGF0L2luZGV4LWJyb3dzZXItb3ZlcndyaXRlLmpzIiwid2VicGFjazovL0BzdWJzdHJhdGUvYnVybnIvLi4vLi4vbm9kZV9tb2R1bGVzL0BzdWJzdHJhdGUvc21vbGRvdC1saWdodC9kaXN0L2hlYWx0aC5qcyIsIndlYnBhY2s6Ly9Ac3Vic3RyYXRlL2J1cm5yLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly9Ac3Vic3RyYXRlL2J1cm5yLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvZGlzdC93b3JrZXIvc3Bhd24tYnJvd3Nlci1vdmVyd3JpdGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbmltcG9ydCB7IHdvcmtlck9uTWVzc2FnZSwgd29ya2VyT25FcnJvciwgd29ya2VyVGVybWluYXRlIH0gZnJvbSAnLi9jb21wYXQvaW5kZXguanMnO1xuaW1wb3J0IHNwYXduV29ya2VyIGZyb20gJy4vd29ya2VyL3NwYXduLmpzJztcbi8qKlxuICogVGhyb3duIGluIGNhc2Ugb2YgYSBwcm9ibGVtIHdoZW4gaW5pdGlhbGl6aW5nIHRoZSBjaGFpbi5cbiAqL1xuZXhwb3J0IGNsYXNzIEFkZENoYWluRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIFRocm93biBpbiBjYXNlIHRoZSBBUEkgdXNlciB0cmllcyB0byB1c2UgYSBjaGFpbiBvciBjbGllbnQgdGhhdCBoYXMgYWxyZWFkeSBiZWVuIGRlc3Ryb3llZC5cbiAqL1xuZXhwb3J0IGNsYXNzIEFscmVhZHlEZXN0cm95ZWRFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qKlxuICogVGhyb3duIHdoZW4gdHJ5aW5nIHRvIHNlbmQgYSBKU09OLVJQQyBtZXNzYWdlIHRvIGEgY2hhaW4gd2hvc2UgSlNPTi1SUEMgc3lzdGVtIGhhc24ndCBiZWVuXG4gKiBlbmFibGVkLlxuICovXG5leHBvcnQgY2xhc3MgSnNvblJwY0Rpc2FibGVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKipcbiAqIFRocm93biBpbiBjYXNlIHRoZSB1bmRlcmx5aW5nIGNsaWVudCBlbmNvdW50ZXJzIGFuIHVuZXhwZWN0ZWQgY3Jhc2guXG4gKlxuICogVGhpcyBpcyBhbHdheXMgYW4gaW50ZXJuYWwgYnVnIGluIHNtb2xkb3QgYW5kIGlzIG5ldmVyIHN1cHBvc2VkIHRvIGhhcHBlbi5cbiAqL1xuZXhwb3J0IGNsYXNzIENyYXNoRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG4vKipcbiAqIEluaXRpYWxpemVzIGEgbmV3IGNsaWVudC4gVGhpcyBpcyBhIHByZS1yZXF1aXNpdGUgdG8gY29ubmVjdGluZyB0byBhIGJsb2NrY2hhaW4uXG4gKlxuICogQ2FuIG5ldmVyIGZhaWwuXG4gKlxuICogQHBhcmFtIG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvZiB0aGUgY2xpZW50LiBEZWZhdWx0cyB0byBge31gLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhcnQob3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGNvbnN0IGxvZ0NhbGxiYWNrID0gb3B0aW9ucy5sb2dDYWxsYmFjayB8fCAoKGxldmVsLCB0YXJnZXQsIG1lc3NhZ2UpID0+IHtcbiAgICAgICAgLy8gVGhlIGZpcnN0IHBhcmFtZXRlciBvZiB0aGUgbWV0aG9kcyBvZiBgY29uc29sZWAgaGFzIHNvbWUgcHJpbnRmLWxpa2Ugc3Vic3RpdHV0aW9uXG4gICAgICAgIC8vIGNhcGFiaWxpdGllcy4gV2UgZG9uJ3QgcmVhbGx5IG5lZWQgdG8gdXNlIHRoaXMsIGJ1dCBub3QgdXNpbmcgaXQgbWVhbnMgdGhhdCB0aGUgbG9ncyBtaWdodFxuICAgICAgICAvLyBub3QgZ2V0IHByaW50ZWQgY29ycmVjdGx5IGlmIHRoZXkgY29udGFpbiBgJWAuXG4gICAgICAgIGlmIChsZXZlbCA8PSAxKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiWyVzXSAlc1wiLCB0YXJnZXQsIG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGxldmVsID09IDIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlslc10gJXNcIiwgdGFyZ2V0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZXZlbCA9PSAzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmluZm8oXCJbJXNdICVzXCIsIHRhcmdldCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGV2ZWwgPT0gNCkge1xuICAgICAgICAgICAgY29uc29sZS5kZWJ1ZyhcIlslc10gJXNcIiwgdGFyZ2V0LCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUudHJhY2UoXCJbJXNdICVzXCIsIHRhcmdldCwgbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBUaGUgYWN0dWFsIGV4ZWN1dGlvbiBvZiBTbW9sZG90IGlzIHBlcmZvcm1lZCBpbiBhIHdvcmtlciB0aHJlYWQuXG4gICAgLy8gQmVjYXVzZSB0aGlzIHNwZWNpZmljIGxpbmUgb2YgY29kZSBpcyBhIGJpdCBzZW5zaXRpdmUsIGl0IGlzIGRvbmUgaW4gYSBzZXBhcmF0ZSBmaWxlLlxuICAgIGNvbnN0IHdvcmtlciA9IHNwYXduV29ya2VyKCk7XG4gICAgbGV0IHdvcmtlckVycm9yID0gbnVsbDtcbiAgICAvLyBXaGVuZXZlciBhbiBgYWRkQ2hhaW5gIG9yIGByZW1vdmVDaGFpbmAgbWVzc2FnZSBpcyBzZW50IHRvIHRoZSB3b3JrZXIsIGEgY29ycmVzcG9uZGluZyBlbnRyeVxuICAgIC8vIGlzIHB1c2hlZCB0byB0aGlzIGFycmF5LiBUaGUgd29ya2VyIG5lZWRzIHRvIHNlbmQgYmFjayBhIGNvbmZpcm1hdGlvbiwgd2hpY2ggcG9wcyB0aGUgZmlyc3RcbiAgICAvLyBlbGVtZW50IG9mIHRoaXMgYXJyYXkuIEluIHRoZSBjYXNlIG9mIGBhZGRDaGFpbmAsIGFkZGl0aW9uYWwgZmllbGRzIGFyZSBzdG9yZWQgaW4gdGhpcyBhcnJheVxuICAgIC8vIHRvIGZpbmlzaCB0aGUgaW5pdGlhbGl6YXRpb24gb2YgdGhlIGNoYWluLlxuICAgIGxldCBwZW5kaW5nQ29uZmlybWF0aW9ucyA9IFtdO1xuICAgIC8vIENvbnRhaW5zIHRoZSBpbmZvcm1hdGlvbiBvZiBlYWNoIGNoYWluIHRoYXQgaXMgY3VycmVudGx5LlxuICAgIC8vIEVudHJpZXMgYXJlIGluc3RhbnRseSByZW1vdmVkIHdoZW4gdGhlIHVzZXIgZGVzaXJlcyB0byByZW1vdmUgYSBjaGFpbiBldmVuIGJlZm9yZSB0aGUgd29ya2VyXG4gICAgLy8gaGFzIGNvbmZpcm1lZCB0aGUgcmVtb3ZhbC4gRG9pbmcgc28gYXZvaWRzIGEgcmFjZSBjb25kaXRpb24gd2hlcmUgdGhlIHdvcmtlciBzZW5kcyBiYWNrIGFcbiAgICAvLyBkYXRhYmFzZSBjb250ZW50IG9yIGEgSlNPTi1SUEMgcmVzcG9uc2Uvbm90aWZpY2F0aW9uIGV2ZW4gdGhvdWdoIHdlJ3ZlIGFscmVhZHkgc2VudCBhXG4gICAgLy8gYHJlbW92ZUNoYWluYCBtZXNzYWdlIHRvIGl0LlxuICAgIC8vXG4gICAgLy8gVGhpcyBtYXAgaXMgYWxzbyB1c2VkIGluIGdlbmVyYWwgYXMgYSB3YXkgdG8gY2hlY2sgd2hldGhlciBhIGNoYWluIHN0aWxsIGV4aXN0cy5cbiAgICBsZXQgY2hhaW5zID0gbmV3IE1hcCgpO1xuICAgIC8vIEZvciBlYWNoIGNoYWluIG9iamVjdCByZXR1cm5lZCBieSBgYWRkQ2hhaW5gLCB0aGUgYXNzb2NpYXRlZCBpbnRlcm5hbCBjaGFpbiBpZC5cbiAgICAvL1xuICAgIC8vIEltbWVkaWF0ZWx5IGNsZWFyZWQgd2hlbiBgcmVtb3ZlKClgIGlzIGNhbGxlZCBvbiBhIGNoYWluLlxuICAgIGxldCBjaGFpbklkcyA9IG5ldyBXZWFrTWFwKCk7XG4gICAgLy8gVGhlIHdvcmtlciBwZXJpb2RpY2FsbHkgcmVwb3J0cyB0aGUgbmFtZSBvZiB0aGUgdGFzayBpdCBpcyBjdXJyZW50bHkgaW4uIFRoaXMgbWFrZXMgaXRcbiAgICAvLyBwb3NzaWJsZSwgd2hlbiB0aGUgd29ya2VyIGlzIGZyb3plbiwgdG8ga25vdyB3aGljaCB0YXNrIGl0IHdhcyBpbiB3aGVuIGZyb3plbi5cbiAgICBjb25zdCB3b3JrZXJDdXJyZW50VGFzayA9IHsgbmFtZTogbnVsbCB9O1xuICAgIC8vIFRoZSB3b3JrZXIgcGVyaW9kaWNhbGx5IHNlbmRzIGEgbWVzc2FnZSBvZiBraW5kICdsaXZlbmVzc1BpbmcnIGluIG9yZGVyIHRvIG5vdGlmeSB0aGF0IGl0IGlzXG4gICAgLy8gc3RpbGwgYWxpdmUuXG4gICAgLy8gSWYgdGhpcyBsaXZlbmVzcyBwaW5nIGlzbid0IHJlY2VpdmVkIGZvciBhIGxvbmcgdGltZSwgYW4gZXJyb3IgaXMgcmVwb3J0ZWQgaW4gdGhlIGxvZ3MuXG4gICAgLy8gVGhlIGZpcnN0IGNoZWNrIGlzIGRlbGF5ZWQgaW4gb3JkZXIgdG8gYWNjb3VudCBmb3IgdGhlIGZhY3QgdGhhdCB0aGUgd29ya2VyIGhhcyB0byBwZXJmb3JtXG4gICAgLy8gYW4gZXhwZW5zaXZlIGluaXRpYWxpemF0aW9uIHN0ZXAgd2hlbiBpbml0aWFsaXppbmcgdGhlIFdhc20gVk0uXG4gICAgbGV0IGxpdmVuZXNzVGltZW91dCA9IG51bGw7XG4gICAgY29uc3QgcmVzZXRMaXZlbmVzc1RpbWVvdXQgPSAoKSA9PiB7XG4gICAgICAgIGlmIChsaXZlbmVzc1RpbWVvdXQgIT09IG51bGwpXG4gICAgICAgICAgICBnbG9iYWxUaGlzLmNsZWFyVGltZW91dChsaXZlbmVzc1RpbWVvdXQpO1xuICAgICAgICBsaXZlbmVzc1RpbWVvdXQgPSBnbG9iYWxUaGlzLnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgbGl2ZW5lc3NUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlNtb2xkb3QgYXBwZWFycyB1bnJlc3BvbnNpdmVcIiArXG4gICAgICAgICAgICAgICAgKHdvcmtlckN1cnJlbnRUYXNrLm5hbWUgPyAoXCIgd2hpbGUgZXhlY3V0aW5nIHRhc2sgYFwiICsgd29ya2VyQ3VycmVudFRhc2submFtZSArIFwiYFwiKSA6IFwiXCIpICtcbiAgICAgICAgICAgICAgICBcIi4gUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgaHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvc21vbGRvdC9pc3N1ZXMuIElmIHlvdSBoYXZlIGEgXCIgK1xuICAgICAgICAgICAgICAgIFwiZGVidWdnZXIgYXZhaWxhYmxlLCBwbGVhc2UgcGF1c2UgZXhlY3V0aW9uLCBnZW5lcmF0ZSBhIHN0YWNrIHRyYWNlIG9mIHRoZSB0aHJlYWQgXCIgK1xuICAgICAgICAgICAgICAgIFwidGhhdCBpc24ndCB0aGUgbWFpbiBleGVjdXRpb24gdGhyZWFkLCBhbmQgcGFzdGUgaXQgaW4gdGhlIGlzc3VlLiBQbGVhc2UgYWxzbyBpbmNsdWRlIFwiICtcbiAgICAgICAgICAgICAgICBcImFueSBvdGhlciBsb2cgZm91bmQgaW4gdGhlIGNvbnNvbGUgb3IgZWxzZXdoZXJlLlwiKTtcbiAgICAgICAgfSwgMTAwMDApO1xuICAgIH07XG4gICAgZ2xvYmFsVGhpcy5zZXRUaW1lb3V0KCgpID0+IHJlc2V0TGl2ZW5lc3NUaW1lb3V0KCksIDE1MDAwKTtcbiAgICAvLyBUaGUgd29ya2VyIGNhbiBzZW5kIHVzIG1lc3NhZ2VzIHdob3NlIHR5cGUgaXMgaWRlbnRpZmllZCB0aHJvdWdoIGEgYGtpbmRgIGZpZWxkLlxuICAgIHdvcmtlck9uTWVzc2FnZSh3b3JrZXIsIChtZXNzYWdlKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobWVzc2FnZS5raW5kKSB7XG4gICAgICAgICAgICBjYXNlICdqc29ucnBjJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNiID0gY2hhaW5zLmdldChtZXNzYWdlLmNoYWluSWQpPy5qc29uUnBjQ2FsbGJhY2s7XG4gICAgICAgICAgICAgICAgaWYgKGNiKVxuICAgICAgICAgICAgICAgICAgICBjYihtZXNzYWdlLmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnY2hhaW5BZGRlZE9rJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gcGVuZGluZ0NvbmZpcm1hdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFpbklkID0gbWVzc2FnZS5jaGFpbklkO1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbnMuaGFzKGNoYWluSWQpKSAvLyBTYW5pdHkgY2hlY2suXG4gICAgICAgICAgICAgICAgICAgIHRocm93ICdVbmV4cGVjdGVkIHJldXNlIG9mIGEgY2hhaW4gSUQnO1xuICAgICAgICAgICAgICAgIGNoYWlucy5zZXQoY2hhaW5JZCwge1xuICAgICAgICAgICAgICAgICAgICBqc29uUnBjQ2FsbGJhY2s6IGV4cGVjdGVkLmpzb25ScGNDYWxsYmFjayxcbiAgICAgICAgICAgICAgICAgICAgZGF0YWJhc2VQcm9taXNlczogbmV3IEFycmF5KClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBgZXhwZWN0ZWRgIHdhcyBwdXNoZWQgYnkgdGhlIGBhZGRDaGFpbmAgbWV0aG9kLlxuICAgICAgICAgICAgICAgIC8vIFJlc29sdmUgdGhlIHByb21pc2UgdGhhdCBgYWRkQ2hhaW5gIHJldHVybmVkIHRvIHRoZSB1c2VyLlxuICAgICAgICAgICAgICAgIGNvbnN0IG5ld0NoYWluID0ge1xuICAgICAgICAgICAgICAgICAgICBzZW5kSnNvblJwYzogKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh3b3JrZXJFcnJvcilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyB3b3JrZXJFcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY2hhaW5zLmhhcyhjaGFpbklkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShjaGFpbnMuZ2V0KGNoYWluSWQpPy5qc29uUnBjQ2FsbGJhY2spKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBKc29uUnBjRGlzYWJsZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcXVlc3QubGVuZ3RoID49IDggKiAxMDI0ICogMTAyNClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh3b3JrZXIsIHsgdHk6ICdyZXF1ZXN0JywgcmVxdWVzdCwgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YWJhc2VDb250ZW50OiAobWF4VXRmOEJ5dGVzU2l6ZSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtlckVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdCh3b3JrZXJFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhYmFzZUNvbnRlbnRQcm9taXNlcyA9IGNoYWlucy5nZXQoY2hhaW5JZCk/LmRhdGFiYXNlUHJvbWlzZXM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGFiYXNlQ29udGVudFByb21pc2VzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhYmFzZUNvbnRlbnRQcm9taXNlcy5wdXNoKHsgcmVzb2x2ZSwgcmVqZWN0IH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0d29Qb3dlcjMyID0gKDEgPDwgMzApICogNDsgLy8gYDEgPDwgMzFgIGFuZCBgMSA8PCAzMmAgaW4gSmF2YVNjcmlwdCBkb24ndCBnaXZlIHRoZSB2YWx1ZSB0aGF0IHlvdSBleHBlY3QuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXhTaXplID0gbWF4VXRmOEJ5dGVzU2l6ZSB8fCAodHdvUG93ZXIzMiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FwcGVkTWF4U2l6ZSA9IChtYXhTaXplID49IHR3b1Bvd2VyMzIpID8gKHR3b1Bvd2VyMzIgLSAxKSA6IG1heFNpemU7XG4gICAgICAgICAgICAgICAgICAgICAgICBwb3N0TWVzc2FnZSh3b3JrZXIsIHsgdHk6ICdkYXRhYmFzZUNvbnRlbnQnLCBjaGFpbklkLCBtYXhVdGY4Qnl0ZXNTaXplOiBjYXBwZWRNYXhTaXplIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHdvcmtlckVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IHdvcmtlckVycm9yO1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQmVjYXVzZSB0aGUgYHJlbW92ZUNoYWluYCBtZXNzYWdlIGlzIGFzeW5jaHJvbm91cywgaXQgaXMgcG9zc2libGUgZm9yIGEgSlNPTi1SUENcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3BvbnNlIG9yIGRhdGFiYXNlIGNvbnRlbnQgY29uY2VybmluZyB0aGF0IGBjaGFpbklkYCB0byBhcnJpdmUgYWZ0ZXIgdGhlIGByZW1vdmVgXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBmdW5jdGlvbiBoYXMgcmV0dXJuZWQuIFdlIHNvbHZlIHRoYXQgYnkgcmVtb3ZpbmcgdGhlIGluZm9ybWF0aW9uIGltbWVkaWF0ZWx5LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGFpbnMuZGVsZXRlKGNoYWluSWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuYXNzZXJ0KGNoYWluSWRzLmhhcyhuZXdDaGFpbikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hhaW5JZHMuZGVsZXRlKG5ld0NoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlKHdvcmtlciwgeyB0eTogJ3JlbW92ZUNoYWluJywgY2hhaW5JZCB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNoYWluSWRzLnNldChuZXdDaGFpbiwgY2hhaW5JZCk7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQucmVzb2x2ZShuZXdDaGFpbik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdjaGFpbkFkZGVkRXJyJzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkID0gcGVuZGluZ0NvbmZpcm1hdGlvbnMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAvLyBgZXhwZWN0ZWRgIHdhcyBwdXNoZWQgYnkgdGhlIGBhZGRDaGFpbmAgbWV0aG9kLlxuICAgICAgICAgICAgICAgIC8vIFJlamVjdCB0aGUgcHJvbWlzZSB0aGF0IGBhZGRDaGFpbmAgcmV0dXJuZWQgdG8gdGhlIHVzZXIuXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQucmVqZWN0KG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnZGF0YWJhc2VDb250ZW50Jzoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb21pc2VzID0gY2hhaW5zLmdldChtZXNzYWdlLmNoYWluSWQpPy5kYXRhYmFzZVByb21pc2VzO1xuICAgICAgICAgICAgICAgIGlmIChwcm9taXNlcylcbiAgICAgICAgICAgICAgICAgICAgcHJvbWlzZXMuc2hpZnQoKS5yZXNvbHZlKG1lc3NhZ2UuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsb2cnOiB7XG4gICAgICAgICAgICAgICAgbG9nQ2FsbGJhY2sobWVzc2FnZS5sZXZlbCwgbWVzc2FnZS50YXJnZXQsIG1lc3NhZ2UubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdsaXZlbmVzc1BpbmcnOiB7XG4gICAgICAgICAgICAgICAgcmVzZXRMaXZlbmVzc1RpbWVvdXQoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2N1cnJlbnRUYXNrJzoge1xuICAgICAgICAgICAgICAgIHdvcmtlckN1cnJlbnRUYXNrLm5hbWUgPSBtZXNzYWdlLnRhc2tOYW1lO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIC8vIEV4aGF1c3RpdmUgY2hlY2suXG4gICAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1lc3NhZ2U7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9leGhhdXN0aXZlQ2hlY2s7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICB3b3JrZXJPbkVycm9yKHdvcmtlciwgKGVycm9yKSA9PiB7XG4gICAgICAgIC8vIEEgd29ya2VyIGVycm9yIHNob3VsZCBvbmx5IGhhcHBlbiBpbiBjYXNlIG9mIGEgY3JpdGljYWwgZXJyb3IgYXMgdGhlIHJlc3VsdCBvZiBhIGJ1Z1xuICAgICAgICAvLyBzb21ld2hlcmUuIENvbnNlcXVlbnRseSwgbm90aGluZyBpcyByZWFsbHkgaW4gcGxhY2UgdG8gY2xlYW5seSByZXBvcnQgdGhlIGVycm9yLlxuICAgICAgICBjb25zb2xlLmVycm9yKFwiU21vbGRvdCBoYXMgcGFuaWNrZWRcIiArXG4gICAgICAgICAgICAod29ya2VyQ3VycmVudFRhc2submFtZSA/IChcIiB3aGlsZSBleGVjdXRpbmcgdGFzayBgXCIgKyB3b3JrZXJDdXJyZW50VGFzay5uYW1lICsgXCJgXCIpIDogXCJcIikgK1xuICAgICAgICAgICAgXCIuIFRoaXMgaXMgYSBidWcgaW4gc21vbGRvdC4gUGxlYXNlIG9wZW4gYW4gaXNzdWUgYXQgXCIgK1xuICAgICAgICAgICAgXCJodHRwczovL2dpdGh1Yi5jb20vcGFyaXR5dGVjaC9zbW9sZG90L2lzc3VlcyB3aXRoIHRoZSBmb2xsb3dpbmcgbWVzc2FnZTpcIik7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgICAgICB3b3JrZXJFcnJvciA9IG5ldyBDcmFzaEVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAvLyBSZWplY3QgYWxsIHByb21pc2VzIHJldHVybmVkIGJ5IGBhZGRDaGFpbmAuXG4gICAgICAgIGZvciAodmFyIHBlbmRpbmcgb2YgcGVuZGluZ0NvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nLnR5ID09ICdjaGFpbkFkZGVkJylcbiAgICAgICAgICAgICAgICBwZW5kaW5nLnJlamVjdCh3b3JrZXJFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgcGVuZGluZ0NvbmZpcm1hdGlvbnMgPSBbXTtcbiAgICAgICAgLy8gUmVqZWN0IGFsbCBwcm9taXNlcyBmb3IgZGF0YWJhc2UgY29udGVudHMuXG4gICAgICAgIGZvciAoY29uc3QgY2hhaW4gb2YgY2hhaW5zKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHByb21pc2Ugb2YgY2hhaW5bMV0uZGF0YWJhc2VQcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHByb21pc2UucmVqZWN0KHdvcmtlckVycm9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjaGFpbnMuY2xlYXIoKTtcbiAgICB9KTtcbiAgICAvLyBUaGUgZmlyc3QgbWVzc2FnZSBleHBlY3RlZCBieSB0aGUgd29ya2VyIGNvbnRhaW5zIHRoZSBjb25maWd1cmF0aW9uLlxuICAgIHBvc3RNZXNzYWdlKHdvcmtlciwge1xuICAgICAgICAvLyBNYXhpbXVtIGxldmVsIG9mIGxvZyBlbnRyaWVzIHNlbnQgYnkgdGhlIGNsaWVudC5cbiAgICAgICAgLy8gMCA9IExvZ2dpbmcgZGlzYWJsZWQsIDEgPSBFcnJvciwgMiA9IFdhcm4sIDMgPSBJbmZvLCA0ID0gRGVidWcsIDUgPSBUcmFjZVxuICAgICAgICBtYXhMb2dMZXZlbDogb3B0aW9ucy5tYXhMb2dMZXZlbCB8fCAzLFxuICAgICAgICBlbmFibGVDdXJyZW50VGFzazogdHJ1ZSxcbiAgICAgICAgZm9yYmlkVGNwOiBvcHRpb25zLmZvcmJpZFRjcCB8fCBmYWxzZSxcbiAgICAgICAgZm9yYmlkV3M6IG9wdGlvbnMuZm9yYmlkV3MgfHwgZmFsc2UsXG4gICAgICAgIGZvcmJpZE5vbkxvY2FsV3M6IG9wdGlvbnMuZm9yYmlkTm9uTG9jYWxXcyB8fCBmYWxzZSxcbiAgICAgICAgZm9yYmlkV3NzOiBvcHRpb25zLmZvcmJpZFdzcyB8fCBmYWxzZSxcbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRDaGFpbjogKG9wdGlvbnMpID0+IHtcbiAgICAgICAgICAgIGlmICh3b3JrZXJFcnJvcilcbiAgICAgICAgICAgICAgICB0aHJvdyB3b3JrZXJFcnJvcjtcbiAgICAgICAgICAgIGxldCBwb3RlbnRpYWxSZWxheUNoYWluc0lkcyA9IFtdO1xuICAgICAgICAgICAgaWYgKCEhb3B0aW9ucy5wb3RlbnRpYWxSZWxheUNoYWlucykge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY2hhaW4gb2Ygb3B0aW9ucy5wb3RlbnRpYWxSZWxheUNoYWlucykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgY29udGVudCBvZiBgb3B0aW9ucy5wb3RlbnRpYWxSZWxheUNoYWluc2AgYXJlIHN1cHBvc2VkIHRvIGJlIGNoYWlucyBlYXJsaWVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHJldHVybmVkIGJ5IGBhZGRDaGFpbmAuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlkID0gY2hhaW5JZHMuZ2V0KGNoYWluKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkID09PSB1bmRlZmluZWQpIC8vIEl0IGlzIHBvc3NpYmxlIGZvciBgaWRgIHRvIGJlIG1pc3NpbmcgaWYgaXQgaGFzIGVhcmxpZXIgYmVlbiByZW1vdmVkLlxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIHBvdGVudGlhbFJlbGF5Q2hhaW5zSWRzLnB1c2goaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEJ1aWxkIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYWZ0ZXIgdGhlIGNoYWluIGhhcyBiZWVuIGFkZGVkLlxuICAgICAgICAgICAgLy8gVE9ETzogYmVjYXVzZSBvZiBodHRwczovL2dpdGh1Yi5jb20vbWljcm9zb2Z0L1R5cGVTY3JpcHQvaXNzdWVzLzExNDk4IHdlIG5lZWQgdG8gZGVmaW5lIHRoZSBjYWxsYmFja3MgYXMgcG9zc2libHkgbnVsbCwgYW5kIGdvIHRocm91Z2ggYHVua25vd25gXG4gICAgICAgICAgICBsZXQgY2hhaW5BZGRlZFByb21pc2VSZXNvbHZlO1xuICAgICAgICAgICAgbGV0IGNoYWluQWRkZWRQcm9taXNlUmVqZWN0O1xuICAgICAgICAgICAgY29uc3QgY2hhaW5BZGRlZFByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY2hhaW5BZGRlZFByb21pc2VSZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgICAgICBjaGFpbkFkZGVkUHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGVuZGluZ0NvbmZpcm1hdGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHk6ICdjaGFpbkFkZGVkJyxcbiAgICAgICAgICAgICAgICByZWplY3Q6IGNoYWluQWRkZWRQcm9taXNlUmVqZWN0LFxuICAgICAgICAgICAgICAgIHJlc29sdmU6IGNoYWluQWRkZWRQcm9taXNlUmVzb2x2ZSxcbiAgICAgICAgICAgICAgICBqc29uUnBjQ2FsbGJhY2s6IG9wdGlvbnMuanNvblJwY0NhbGxiYWNrLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwb3N0TWVzc2FnZSh3b3JrZXIsIHtcbiAgICAgICAgICAgICAgICB0eTogJ2FkZENoYWluJyxcbiAgICAgICAgICAgICAgICBjaGFpblNwZWM6IG9wdGlvbnMuY2hhaW5TcGVjLFxuICAgICAgICAgICAgICAgIGRhdGFiYXNlQ29udGVudDogdHlwZW9mIG9wdGlvbnMuZGF0YWJhc2VDb250ZW50ID09PSAnc3RyaW5nJyA/IG9wdGlvbnMuZGF0YWJhc2VDb250ZW50IDogXCJcIixcbiAgICAgICAgICAgICAgICBwb3RlbnRpYWxSZWxheUNoYWluczogcG90ZW50aWFsUmVsYXlDaGFpbnNJZHMsXG4gICAgICAgICAgICAgICAganNvblJwY1J1bm5pbmc6ICEhb3B0aW9ucy5qc29uUnBjQ2FsbGJhY2ssXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBjaGFpbkFkZGVkUHJvbWlzZTtcbiAgICAgICAgfSxcbiAgICAgICAgdGVybWluYXRlOiAoKSA9PiB7XG4gICAgICAgICAgICBpZiAod29ya2VyRXJyb3IpXG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KHdvcmtlckVycm9yKTtcbiAgICAgICAgICAgIHdvcmtlckVycm9yID0gbmV3IEFscmVhZHlEZXN0cm95ZWRFcnJvcigpO1xuICAgICAgICAgICAgaWYgKGxpdmVuZXNzVGltZW91dCAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICBnbG9iYWxUaGlzLmNsZWFyVGltZW91dChsaXZlbmVzc1RpbWVvdXQpO1xuICAgICAgICAgICAgcmV0dXJuIHdvcmtlclRlcm1pbmF0ZSh3b3JrZXIpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbi8vIFNlcGFyYXRlIGZ1bmN0aW9uIGluIG9yZGVyIHRvIGVuZm9yY2UgdHlwZXMuXG5mdW5jdGlvbiBwb3N0TWVzc2FnZSh3b3JrZXIsIG1lc3NhZ2UpIHtcbiAgICB3b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSk7XG59XG4iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMiAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcbi8vIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4vLyBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuLy8gdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgZWl0aGVyIHZlcnNpb24gMyBvZiB0aGUgTGljZW5zZSwgb3Jcbi8vIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuLy8gT3ZlcnJpZGVzIGBpbmRleC5qc2Agd2hlbiBpbiBhIGJyb3dzZXIuXG5leHBvcnQgZnVuY3Rpb24gd29ya2VyT25NZXNzYWdlKHdvcmtlciwgY2FsbGJhY2spIHtcbiAgICB3b3JrZXIub25tZXNzYWdlID0gKGV2ZW50KSA9PiBjYWxsYmFjayhldmVudC5kYXRhKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB3b3JrZXJPbkVycm9yKHdvcmtlciwgY2FsbGJhY2spIHtcbiAgICAvLyBUT0RPOiB1bmNsZWFyIGlmIHRoZSBwYXJhbWV0ZXIgb2YgdGhlIGNhbGxiYWNrIGlzIHNhbWUgYXMgd2l0aCBOb2RlSlNcbiAgICB3b3JrZXIub25lcnJvciA9IGNhbGxiYWNrO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHdvcmtlclRlcm1pbmF0ZSh3b3JrZXIpIHtcbiAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc3RNZXNzYWdlKG1zZykge1xuICAgIHNlbGYucG9zdE1lc3NhZ2UobXNnKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZXRPbk1lc3NhZ2UoY2FsbGJhY2spIHtcbiAgICBzZWxmLm9ubWVzc2FnZSA9IChldmVudCkgPT4gY2FsbGJhY2soZXZlbnQuZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGVyZm9ybWFuY2VOb3coKSB7XG4gICAgcmV0dXJuIHBlcmZvcm1hbmNlLm5vdygpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzVGNwQXZhaWxhYmxlKCkge1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uKF9vcHRzLCBfY29ubmVjdGlvbkxpc3RlbmVyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdUQ1AgY29ubmVjdGlvbnMgbm90IGF2YWlsYWJsZScpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFJhbmRvbVZhbHVlcyhidWZmZXIpIHtcbiAgICBjb25zdCBjcnlwdG8gPSBnbG9iYWxUaGlzLmNyeXB0bztcbiAgICBpZiAoIWNyeXB0bylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyYW5kb21uZXNzIG5vdCBhdmFpbGFibGUnKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKGJ1ZmZlcik7XG59XG4iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMiAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcbnZhciBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0ID0gKHRoaXMgJiYgdGhpcy5fX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KSB8fCBmdW5jdGlvbiAocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcIm1cIikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgbWV0aG9kIGlzIG5vdCB3cml0YWJsZVwiKTtcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBzZXR0ZXJcIik7XG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4gKGtpbmQgPT09IFwiYVwiID8gZi5jYWxsKHJlY2VpdmVyLCB2YWx1ZSkgOiBmID8gZi52YWx1ZSA9IHZhbHVlIDogc3RhdGUuc2V0KHJlY2VpdmVyLCB2YWx1ZSkpLCB2YWx1ZTtcbn07XG52YXIgX19jbGFzc1ByaXZhdGVGaWVsZEdldCA9ICh0aGlzICYmIHRoaXMuX19jbGFzc1ByaXZhdGVGaWVsZEdldCkgfHwgZnVuY3Rpb24gKHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xuICAgIGlmIChraW5kID09PSBcImFcIiAmJiAhZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlByaXZhdGUgYWNjZXNzb3Igd2FzIGRlZmluZWQgd2l0aG91dCBhIGdldHRlclwiKTtcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xufTtcbnZhciBfSW5uZXJDaGVja2VyX2hlYWx0aENhbGxiYWNrLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhDaGVja0lkLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhUaW1lb3V0LCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCwgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3Vic2NyaXB0aW9uSWQsIF9Jbm5lckNoZWNrZXJfcmVxdWVzdFRvU21vbGRvdCwgX0lubmVyQ2hlY2tlcl9pc1N5bmNpbmcsIF9Jbm5lckNoZWNrZXJfbmV4dFJlcXVlc3RJZDtcbi8qXG4gKiBDcmVhdGVzIGEgbmV3IGhlYWx0aCBjaGVja2VyLlxuICpcbiAqIFRoZSByb2xlIG9mIHRoZSBoZWFsdGggY2hlY2tlciBpcyB0byByZXBvcnQgdG8gdGhlIHVzZXIgdGhlIGhlYWx0aCBvZiBhIHNtb2xkb3QgY2hhaW4uXG4gKlxuICogSW4gb3JkZXIgdG8gdXNlIGl0LCBzdGFydCBieSBjcmVhdGluZyBhIGhlYWx0aCBjaGVja2VyLCBhbmQgY2FsbCBgc2V0U2VuZEpzb25ScGNgIHRvIHNldCB0aGVcbiAqIHdheSB0byBzZW5kIGEgSlNPTi1SUEMgcmVxdWVzdCB0byBhIGNoYWluLiBUaGUgaGVhbHRoIGNoZWNrZXIgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdC4gVXNlXG4gKiBgc3RhcnQoKWAgaW4gb3JkZXIgdG8gc3RhcnQgdGhlIGhlYWx0aCBjaGVja3MuIFRoZSBgc3RhcnQoKWAgZnVuY3Rpb24gbXVzdCBiZSBwYXNzZWQgYSBjYWxsYmFjayBjYWxsZWRcbiAqIHdoZW4gYW4gdXBkYXRlIHRvIHRoZSBoZWFsdGggb2YgdGhlIG5vZGUgaXMgYXZhaWxhYmxlLlxuICpcbiAqIEluIG9yZGVyIHRvIHNlbmQgYSBKU09OLVJQQyByZXF1ZXN0IHRvIHRoZSBjaGFpbiwgeW91ICoqbXVzdCoqIHVzZSB0aGUgYHNlbmRKc29uUnBjYCBmdW5jdGlvblxuICogb2YgdGhlIGhlYWx0aCBjaGVja2VyLiBUaGUgaGVhbHRoIGNoZWNrZXIgcmV3cml0ZXMgdGhlIGBpZGAgb2YgdGhlIHJlcXVlc3RzIGl0IHJlY2VpdmVzLlxuICpcbiAqIFdoZW4gdGhlIGNoYWluIHNlbmQgYSBKU09OLVJQQyByZXNwb25zZSwgaXQgbXVzdCBiZSBwYXNzZWQgdG8gYHJlc3BvbnNlUGFzc1Rocm91Z2goKWAuIFRoaXNcbiAqIGZ1bmN0aW9uIGludGVyY2VwdHMgdGhlIHJlc3BvbnNlcyBkZXN0aW5lZCB0byB0aGUgcmVxdWVzdHMgdGhhdCBoYXZlIGJlZW4gZW1pdHRlZCBieSB0aGUgaGVhbHRoXG4gKiBjaGVja2VyIGFuZCByZXR1cm5zIGBudWxsYC4gSWYgdGhlIHJlc3BvbnNlIGRvZXNuJ3QgY29uY2VybiB0aGUgaGVhbHRoIGNoZWNrZXIsIHRoZSByZXNwb25zZSBpc1xuICogc2ltcGx5IHJldHVybmVkIGJ5IHRoZSBmdW5jdGlvbi5cbiAqXG4gKiAjIEhvdyBpdCB3b3Jrc1xuICpcbiAqIFRoZSBoZWFsdGggY2hlY2tlciBwZXJpb2RpY2FsbHkgY2FsbHMgdGhlIGBzeXN0ZW1faGVhbHRoYCBKU09OLVJQQyBjYWxsIGluIG9yZGVyIHRvIGRldGVybWluZVxuICogdGhlIGhlYWx0aCBvZiB0aGUgY2hhaW4uXG4gKlxuICogSW4gYWRkaXRpb24gdG8gdGhpcywgYXMgbG9uZyBhcyB0aGUgaGVhbHRoIGNoZWNrIHJlcG9ydHMgdGhhdCBgaXNTeW5jaW5nYCBpcyBgdHJ1ZWAsIHRoZVxuICogaGVhbHRoIGNoZWNrZXIgYWxzbyBtYWludGFpbnMgYSBzdWJzY3JpcHRpb24gdG8gbmV3IGJlc3QgYmxvY2tzIHVzaW5nIGBjaGFpbl9zdWJzY3JpYmVOZXdIZWFkc2AuXG4gKiBXaGVuZXZlciBhIG5ldyBibG9jayBpcyBub3RpZmllZCwgYSBoZWFsdGggY2hlY2sgaXMgcGVyZm9ybWVkIGltbWVkaWF0ZWx5IGluIG9yZGVyIHRvIGRldGVybWluZVxuICogd2hldGhlciBgaXNTeW5jaW5nYCBoYXMgY2hhbmdlZCB0byBgZmFsc2VgLlxuICpcbiAqIFRoYW5rcyB0byB0aGlzIHN1YnNjcmlwdGlvbiwgdGhlIGxhdGVuY3kgb2YgdGhlIHJlcG9ydCBvZiB0aGUgc3dpdGNoIGZyb20gYGlzU3luY2luZzogdHJ1ZWAgdG9cbiAqIGBpc1N5bmNpbmc6IGZhbHNlYCBpcyB2ZXJ5IGxvdy5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBoZWFsdGhDaGVja2VyKCkge1xuICAgIC8vIGBudWxsYCBpZiBoZWFsdGggY2hlY2tlciBpcyBub3Qgc3RhcnRlZC5cbiAgICBsZXQgY2hlY2tlciA9IG51bGw7XG4gICAgbGV0IHNlbmRKc29uUnBjID0gbnVsbDtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXRTZW5kSnNvblJwYzogKGNiKSA9PiB7XG4gICAgICAgICAgICBzZW5kSnNvblJwYyA9IGNiO1xuICAgICAgICB9LFxuICAgICAgICBzdGFydDogKGhlYWx0aENhbGxiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlciAhPT0gbnVsbClcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBzdGFydCB0aGUgaGVhbHRoIGNoZWNrZXIgbXVsdGlwbGUgdGltZXMgaW4gcGFyYWxsZWxcIik7XG4gICAgICAgICAgICBpZiAoIXNlbmRKc29uUnBjKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInNldFNlbmRKc29uUnBjIG11c3QgYmUgY2FsbGVkIGJlZm9yZSBzdGFydGluZyB0aGUgaGVhbHRoIGNoZWNrc1wiKTtcbiAgICAgICAgICAgIGNoZWNrZXIgPSBuZXcgSW5uZXJDaGVja2VyKGhlYWx0aENhbGxiYWNrLCBzZW5kSnNvblJwYyk7XG4gICAgICAgICAgICBjaGVja2VyLnN0YXJ0SGVhbHRoQ2hlY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHN0b3BwZWQuXG4gICAgICAgICAgICBjaGVja2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGNoZWNrZXIgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZW5kSnNvblJwYzogKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGlmICghc2VuZEpzb25ScGMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0U2VuZEpzb25ScGMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHNcIik7XG4gICAgICAgICAgICBpZiAoY2hlY2tlciA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICBzZW5kSnNvblJwYyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGVja2VyLnNlbmRKc29uUnBjKHJlcXVlc3QpO1xuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZVBhc3NUaHJvdWdoOiAoanNvblJwY1Jlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlciA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblJwY1Jlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrZXIucmVzcG9uc2VQYXNzVGhyb3VnaChqc29uUnBjUmVzcG9uc2UpO1xuICAgICAgICB9LFxuICAgIH07XG59XG5jbGFzcyBJbm5lckNoZWNrZXIge1xuICAgIGNvbnN0cnVjdG9yKGhlYWx0aENhbGxiYWNrLCByZXF1ZXN0VG9TbW9sZG90KSB7XG4gICAgICAgIF9Jbm5lckNoZWNrZXJfaGVhbHRoQ2FsbGJhY2suc2V0KHRoaXMsIHZvaWQgMCk7XG4gICAgICAgIF9Jbm5lckNoZWNrZXJfY3VycmVudEhlYWx0aENoZWNrSWQuc2V0KHRoaXMsIG51bGwpO1xuICAgICAgICBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhUaW1lb3V0LnNldCh0aGlzLCBudWxsKTtcbiAgICAgICAgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQuc2V0KHRoaXMsIG51bGwpO1xuICAgICAgICBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJzY3JpcHRpb25JZC5zZXQodGhpcywgbnVsbCk7XG4gICAgICAgIF9Jbm5lckNoZWNrZXJfcmVxdWVzdFRvU21vbGRvdC5zZXQodGhpcywgdm9pZCAwKTtcbiAgICAgICAgX0lubmVyQ2hlY2tlcl9pc1N5bmNpbmcuc2V0KHRoaXMsIGZhbHNlKTtcbiAgICAgICAgX0lubmVyQ2hlY2tlcl9uZXh0UmVxdWVzdElkLnNldCh0aGlzLCAwKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW5uZXJDaGVja2VyX2hlYWx0aENhbGxiYWNrLCBoZWFsdGhDYWxsYmFjaywgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfcmVxdWVzdFRvU21vbGRvdCwgcmVxdWVzdFRvU21vbGRvdCwgXCJmXCIpO1xuICAgIH1cbiAgICBzZW5kSnNvblJwYyhyZXF1ZXN0KSB7XG4gICAgICAgIC8vIFJlcGxhY2UgdGhlIGBpZGAgaW4gdGhlIHJlcXVlc3QgdG8gcHJlZml4IHRoZSByZXF1ZXN0IElEIHdpdGggYGV4dGVybjpgLlxuICAgICAgICBsZXQgcGFyc2VkUmVxdWVzdDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZFJlcXVlc3QgPSBKU09OLnBhcnNlKHJlcXVlc3QpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICA7XG4gICAgICAgIGlmIChwYXJzZWRSZXF1ZXN0LmlkKSB7XG4gICAgICAgICAgICBjb25zdCBuZXdJZCA9ICdleHRlcm46JyArIEpTT04uc3RyaW5naWZ5KHBhcnNlZFJlcXVlc3QuaWQpO1xuICAgICAgICAgICAgcGFyc2VkUmVxdWVzdC5pZCA9IG5ld0lkO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9yZXF1ZXN0VG9TbW9sZG90LCBcImZcIikuY2FsbCh0aGlzLCBKU09OLnN0cmluZ2lmeShwYXJzZWRSZXF1ZXN0KSk7XG4gICAgfVxuICAgIHJlc3BvbnNlUGFzc1Rocm91Z2goanNvblJwY1Jlc3BvbnNlKSB7XG4gICAgICAgIGxldCBwYXJzZWRSZXNwb25zZTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShqc29uUnBjUmVzcG9uc2UpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgIHJldHVybiBqc29uUnBjUmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgICAgO1xuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHJlc3BvbnNlIGlzIGEgcmVzcG9uc2UgdG8gYHN5c3RlbV9oZWFsdGhgLlxuICAgICAgICBpZiAocGFyc2VkUmVzcG9uc2UuaWQgJiYgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhDaGVja0lkLCBcImZcIikgPT0gcGFyc2VkUmVzcG9uc2UuaWQpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoQ2hlY2tJZCwgbnVsbCwgXCJmXCIpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciBxdWVyeSB3YXMgc3VjY2Vzc2Z1bC4gSXQgaXMgcG9zc2libGUgZm9yIHF1ZXJpZXMgdG8gZmFpbCBmb3JcbiAgICAgICAgICAgIC8vIHZhcmlvdXMgcmVhc29ucywgc3VjaCBhcyB0aGUgY2xpZW50IGJlaW5nIG92ZXJsb2FkZWQuXG4gICAgICAgICAgICBpZiAoIXBhcnNlZFJlc3BvbnNlLnJlc3VsdCkge1xuICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfaGVhbHRoQ2FsbGJhY2ssIFwiZlwiKS5jYWxsKHRoaXMsIHBhcnNlZFJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfaXNTeW5jaW5nLCBwYXJzZWRSZXNwb25zZS5yZXN1bHQuaXNTeW5jaW5nLCBcImZcIik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciByZXNwb25zZSBpcyBhIHJlc3BvbnNlIHRvIHRoZSBzdWJzY3JpcHRpb24gb3IgdW5zdWJzY3JpcHRpb24uXG4gICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5pZCAmJiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnVuc3ViUmVxdWVzdElkLCBcImZcIikgPT0gcGFyc2VkUmVzcG9uc2UuaWQpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQsIG51bGwsIFwiZlwiKTtcbiAgICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgcXVlcnkgd2FzIHN1Y2Nlc3NmdWwuIEl0IGlzIHBvc3NpYmxlIGZvciBxdWVyaWVzIHRvIGZhaWwgZm9yXG4gICAgICAgICAgICAvLyB2YXJpb3VzIHJlYXNvbnMsIHN1Y2ggYXMgdGhlIGNsaWVudCBiZWluZyBvdmVybG9hZGVkLlxuICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXNwb25zZS5yZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3Vic2NyaXB0aW9uSWQsIFwiZlwiKSlcbiAgICAgICAgICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnNjcmlwdGlvbklkLCBudWxsLCBcImZcIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJzY3JpcHRpb25JZCwgcGFyc2VkUmVzcG9uc2UucmVzdWx0LCBcImZcIik7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgd2hldGhlciByZXNwb25zZSBpcyBhIG5vdGlmaWNhdGlvbiB0byBhIHN1YnNjcmlwdGlvbi5cbiAgICAgICAgaWYgKHBhcnNlZFJlc3BvbnNlLnBhcmFtcyAmJiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnNjcmlwdGlvbklkLCBcImZcIikgJiZcbiAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlLnBhcmFtcy5zdWJzY3JpcHRpb24gPT0gX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJzY3JpcHRpb25JZCwgXCJmXCIpKSB7XG4gICAgICAgICAgICAvLyBOb3RlIHRoYXQgYWZ0ZXIgYSBzdWNjZXNzZnVsIHN1YnNjcmlwdGlvbiwgYSBub3RpZmljYXRpb24gY29udGFpbmluZ1xuICAgICAgICAgICAgLy8gdGhlIGN1cnJlbnQgYmVzdCBibG9jayBpcyBhbHdheXMgcmV0dXJuZWQuIENvbnNpZGVyaW5nIHRoYXQgYVxuICAgICAgICAgICAgLy8gc3Vic2NyaXB0aW9uIGlzIHBlcmZvcm1lZCBpbiByZXNwb25zZSB0byBhIGhlYWx0aCBjaGVjaywgY2FsbGluZ1xuICAgICAgICAgICAgLy8gYHN0YXJ0SGVhbHRoQ2hlY2soKWAgaGVyZSB3aWxsIGxlYWQgdG8gYSBzZWNvbmQgaGVhbHRoIGNoZWNrLlxuICAgICAgICAgICAgLy8gSXQgbWlnaHQgc2VlbSByZWR1bmRhbnQgdG8gcGVyZm9ybSB0d28gaGVhbHRoIGNoZWNrcyBpbiBhIHF1aWNrXG4gICAgICAgICAgICAvLyBzdWNjZXNzaW9uLCBidXQgZG9pbmcgc28gZG9lc24ndCBsZWFkIHRvIGFueSBwcm9ibGVtLCBhbmQgaXQgaXNcbiAgICAgICAgICAgIC8vIGFjdHVhbGx5IHBvc3NpYmxlIGZvciB0aGUgaGVhbHRoIHRvIGhhdmUgY2hhbmdlZCBpbiBiZXR3ZWVuIGFzIHRoZVxuICAgICAgICAgICAgLy8gY3VycmVudCBiZXN0IGJsb2NrIG1pZ2h0IGhhdmUgYmVlbiB1cGRhdGVkIGR1cmluZyB0aGUgc3Vic2NyaXB0aW9uXG4gICAgICAgICAgICAvLyByZXF1ZXN0LlxuICAgICAgICAgICAgdGhpcy5zdGFydEhlYWx0aENoZWNrKCk7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzcG9uc2UgZG9lc24ndCBjb25jZXJuIHVzLlxuICAgICAgICBpZiAocGFyc2VkUmVzcG9uc2UuaWQpIHtcbiAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVtb3ZlIHRoZSBgZXh0ZXJuOmAgcHJlZml4LlxuICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXNwb25zZS5pZC5zdGFydHNXaXRoKCdleHRlcm46JykpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBpbmNvbnNpc3RlbmN5IGluIGhlYWx0aCBjaGVja2VyJyk7XG4gICAgICAgICAgICBjb25zdCBuZXdJZCA9IEpTT04ucGFyc2UocGFyc2VkUmVzcG9uc2UuaWQuc2xpY2UoJ2V4dGVybjonLmxlbmd0aCkpO1xuICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UuaWQgPSBuZXdJZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocGFyc2VkUmVzcG9uc2UpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICAgIGlmICghX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhUaW1lb3V0LCBcImZcIikpIHtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoVGltZW91dCwgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhUaW1lb3V0LCBudWxsLCBcImZcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zdGFydEhlYWx0aENoZWNrKCk7XG4gICAgICAgICAgICB9LCAxMDAwMCksIFwiZlwiKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2lzU3luY2luZywgXCJmXCIpICYmICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnNjcmlwdGlvbklkLCBcImZcIikgJiYgIV9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQsIFwiZlwiKSlcbiAgICAgICAgICAgIHRoaXMuc3RhcnRTdWJzY3JpcHRpb24oKTtcbiAgICAgICAgaWYgKCFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfaXNTeW5jaW5nLCBcImZcIikgJiYgX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJzY3JpcHRpb25JZCwgXCJmXCIpICYmICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnVuc3ViUmVxdWVzdElkLCBcImZcIikpXG4gICAgICAgICAgICB0aGlzLmVuZFN1YnNjcmlwdGlvbigpO1xuICAgIH1cbiAgICBzdGFydEhlYWx0aENoZWNrKCkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhDaGVja0lkLCBcImZcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yIGluIGhlYWx0aCBjaGVja2VyJyk7XG4gICAgICAgIGlmIChfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudEhlYWx0aFRpbWVvdXQsIFwiZlwiKSkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoVGltZW91dCwgXCJmXCIpKTtcbiAgICAgICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoVGltZW91dCwgbnVsbCwgXCJmXCIpO1xuICAgICAgICB9XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoQ2hlY2tJZCwgXCJoZWFsdGgtY2hlY2tlcjpcIiArIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9uZXh0UmVxdWVzdElkLCBcImZcIiksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW5uZXJDaGVja2VyX25leHRSZXF1ZXN0SWQsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9uZXh0UmVxdWVzdElkLCBcImZcIikgKyAxLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9yZXF1ZXN0VG9TbW9sZG90LCBcImZcIikuY2FsbCh0aGlzLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgaWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoQ2hlY2tJZCwgXCJmXCIpLFxuICAgICAgICAgICAgbWV0aG9kOiAnc3lzdGVtX2hlYWx0aCcsXG4gICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHN0YXJ0U3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCwgXCJmXCIpIHx8IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3Vic2NyaXB0aW9uSWQsIFwiZlwiKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW50ZXJuYWwgZXJyb3IgaW4gaGVhbHRoIGNoZWNrZXInKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCwgXCJoZWFsdGgtY2hlY2tlcjpcIiArIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9uZXh0UmVxdWVzdElkLCBcImZcIiksIFwiZlwiKTtcbiAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW5uZXJDaGVja2VyX25leHRSZXF1ZXN0SWQsIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9uZXh0UmVxdWVzdElkLCBcImZcIikgKyAxLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9yZXF1ZXN0VG9TbW9sZG90LCBcImZcIikuY2FsbCh0aGlzLCBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgaWQ6IF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQsIFwiZlwiKSxcbiAgICAgICAgICAgIG1ldGhvZDogJ2NoYWluX3N1YnNjcmliZU5ld0hlYWRzJyxcbiAgICAgICAgICAgIHBhcmFtczogW10sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZW5kU3Vic2NyaXB0aW9uKCkge1xuICAgICAgICBpZiAoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCwgXCJmXCIpIHx8ICFfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnNjcmlwdGlvbklkLCBcImZcIikpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yIGluIGhlYWx0aCBjaGVja2VyJyk7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQsIFwiaGVhbHRoLWNoZWNrZXI6XCIgKyBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfbmV4dFJlcXVlc3RJZCwgXCJmXCIpLCBcImZcIik7XG4gICAgICAgIF9fY2xhc3NQcml2YXRlRmllbGRTZXQodGhpcywgX0lubmVyQ2hlY2tlcl9uZXh0UmVxdWVzdElkLCBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfbmV4dFJlcXVlc3RJZCwgXCJmXCIpICsgMSwgXCJmXCIpO1xuICAgICAgICBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfcmVxdWVzdFRvU21vbGRvdCwgXCJmXCIpLmNhbGwodGhpcywgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgIGlkOiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHRoaXMsIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnVuc3ViUmVxdWVzdElkLCBcImZcIiksXG4gICAgICAgICAgICBtZXRob2Q6ICdjaGFpbl91bnN1YnNjcmliZU5ld0hlYWRzJyxcbiAgICAgICAgICAgIHBhcmFtczogW19fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50U3Vic2NyaXB0aW9uSWQsIFwiZlwiKV0sXG4gICAgICAgIH0pKTtcbiAgICB9XG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgaWYgKF9fY2xhc3NQcml2YXRlRmllbGRHZXQodGhpcywgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoVGltZW91dCwgXCJmXCIpKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoX19jbGFzc1ByaXZhdGVGaWVsZEdldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhUaW1lb3V0LCBcImZcIikpO1xuICAgICAgICAgICAgX19jbGFzc1ByaXZhdGVGaWVsZFNldCh0aGlzLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRIZWFsdGhUaW1lb3V0LCBudWxsLCBcImZcIik7XG4gICAgICAgIH1cbiAgICB9XG59XG5fSW5uZXJDaGVja2VyX2hlYWx0aENhbGxiYWNrID0gbmV3IFdlYWtNYXAoKSwgX0lubmVyQ2hlY2tlcl9jdXJyZW50SGVhbHRoQ2hlY2tJZCA9IG5ldyBXZWFrTWFwKCksIF9Jbm5lckNoZWNrZXJfY3VycmVudEhlYWx0aFRpbWVvdXQgPSBuZXcgV2Vha01hcCgpLCBfSW5uZXJDaGVja2VyX2N1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCA9IG5ldyBXZWFrTWFwKCksIF9Jbm5lckNoZWNrZXJfY3VycmVudFN1YnNjcmlwdGlvbklkID0gbmV3IFdlYWtNYXAoKSwgX0lubmVyQ2hlY2tlcl9yZXF1ZXN0VG9TbW9sZG90ID0gbmV3IFdlYWtNYXAoKSwgX0lubmVyQ2hlY2tlcl9pc1N5bmNpbmcgPSBuZXcgV2Vha01hcCgpLCBfSW5uZXJDaGVja2VyX25leHRSZXF1ZXN0SWQgPSBuZXcgV2Vha01hcCgpO1xuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbmV4cG9ydCB7IGhlYWx0aENoZWNrZXIgfSBmcm9tICcuL2hlYWx0aC5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2NsaWVudC5qcyc7IC8vIFRPRE86IHByZWNpc2UgZXhwb3J0c1xuIiwiLy8gU21vbGRvdFxuLy8gQ29weXJpZ2h0IChDKSAyMDE5LTIwMjIgIFBhcml0eSBUZWNobm9sb2dpZXMgKFVLKSBMdGQuXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogR1BMLTMuMC1vci1sYXRlciBXSVRIIENsYXNzcGF0aC1leGNlcHRpb24tMi4wXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbi8vIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4vLyBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbS4gIElmIG5vdCwgc2VlIDxodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvPi5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIXdpbmRvdy5Xb3JrZXIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIldvcmtlcnMgbm90IGF2YWlsYWJsZVwiKTtcbiAgICAvLyBUaGUgbGluZSBvZiBjb2RlIGJlbG93IChgbmV3IFdvcmtlciguLi4pYCkgaXMgZGVzaWduZWQgdG8gaG9wZWZ1bGx5IHdvcmsgYWNyb3NzIGFsbFxuICAgIC8vIHBsYXRmb3JtcyBhbmQgYnVuZGxlcnMuXG4gICAgLy8gQmVjYXVzZSB0aGlzIGxpbmUgaXMgcHJlY2lzZWx5IHJlY29nbml6ZWQgYnkgYnVuZGxlcnMsIHdlIGV4dHJhY3QgaXQgdG8gYSBzZXBhcmF0ZVxuICAgIC8vIEphdmFTY3JpcHQgZmlsZS5cbiAgICAvLyBTZWUgYWxzbyB0aGUgUkVBRE1FLm1kIGZvciBtb3JlIGNvbnRleHQuXG4gICAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKCcuL3dvcmtlci5qcycsIGltcG9ydC5tZXRhLnVybCksIHsgbmFtZTogXCJzbW9sZG90XCIgfSk7XG4gICAgcmV0dXJuIHdvcmtlcjtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==