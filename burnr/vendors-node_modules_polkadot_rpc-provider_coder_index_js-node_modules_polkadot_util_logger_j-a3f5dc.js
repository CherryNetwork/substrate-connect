"use strict";
(self["webpackChunk_substrate_burnr"] = self["webpackChunk_substrate_burnr"] || []).push([["vendors-node_modules_polkadot_rpc-provider_coder_index_js-node_modules_polkadot_util_logger_j-a3f5dc"],{

/***/ "../../node_modules/@polkadot/rpc-provider/coder/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@polkadot/rpc-provider/coder/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "RpcCoder": () => (/* binding */ RpcCoder)
/* harmony export */ });
/* harmony import */ var _babel_runtime_helpers_esm_classPrivateFieldLooseBase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classPrivateFieldLooseBase */ "../../node_modules/@polkadot/rpc-provider/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js");
/* harmony import */ var _babel_runtime_helpers_esm_classPrivateFieldLooseKey__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/classPrivateFieldLooseKey */ "../../node_modules/@polkadot/rpc-provider/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js");
/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/is/undefined.js");
/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/is/string.js");
/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/stringify.js");
/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/assert.js");
/* harmony import */ var _polkadot_util__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @polkadot/util */ "../../node_modules/@polkadot/util/is/number.js");


// Copyright 2017-2021 @polkadot/rpc-provider authors & contributors
// SPDX-License-Identifier: Apache-2.0


function formatErrorData(data) {
  if ((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(data)) {
    return '';
  }

  const formatted = `: ${(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_3__.isString)(data) ? data.replace(/Error\("/g, '').replace(/\("/g, '(').replace(/"\)/g, ')').replace(/\(/g, ', ').replace(/\)/g, '') : (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_4__.stringify)(data)}`; // We need some sort of cut-off here since these can be very large and
  // very nested, pick a number and trim the result display to it

  return formatted.length <= 256 ? formatted : `${formatted.substr(0, 255)}â€¦`;
}
/** @internal */


var _id = /*#__PURE__*/(0,_babel_runtime_helpers_esm_classPrivateFieldLooseKey__WEBPACK_IMPORTED_MODULE_1__["default"])("id");

class RpcCoder {
  constructor() {
    Object.defineProperty(this, _id, {
      writable: true,
      value: 0
    });
  }

  decodeResponse(response) {
    (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.assert)(response, 'Empty response object received');
    (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.assert)(response.jsonrpc === '2.0', 'Invalid jsonrpc field in decoded object');
    const isSubscription = !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(response.params) && !(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(response.method);
    (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.assert)((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_6__.isNumber)(response.id) || isSubscription && ((0,_polkadot_util__WEBPACK_IMPORTED_MODULE_6__.isNumber)(response.params.subscription) || (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_3__.isString)(response.params.subscription)), 'Invalid id field in decoded object');

    this._checkError(response.error);

    (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_5__.assert)(!(0,_polkadot_util__WEBPACK_IMPORTED_MODULE_2__.isUndefined)(response.result) || isSubscription, 'No result found in JsonRpc response');

    if (isSubscription) {
      this._checkError(response.params.error);

      return response.params.result;
    }

    return response.result;
  }

  encodeJson(method, params) {
    return (0,_polkadot_util__WEBPACK_IMPORTED_MODULE_4__.stringify)(this.encodeObject(method, params));
  }

  encodeObject(method, params) {
    return {
      id: ++(0,_babel_runtime_helpers_esm_classPrivateFieldLooseBase__WEBPACK_IMPORTED_MODULE_0__["default"])(this, _id)[_id],
      jsonrpc: '2.0',
      method,
      params
    };
  }

  getId() {
    return (0,_babel_runtime_helpers_esm_classPrivateFieldLooseBase__WEBPACK_IMPORTED_MODULE_0__["default"])(this, _id)[_id];
  }

  _checkError(error) {
    if (error) {
      const {
        code,
        data,
        message
      } = error;
      throw new Error(`${code}: ${message}${formatErrorData(data)}`);
    }
  }

}

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js":
/*!***********************************************************************************************************************!*\
  !*** ../../node_modules/@polkadot/rpc-provider/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseBase.js ***!
  \***********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classPrivateFieldBase)
/* harmony export */ });
function _classPrivateFieldBase(receiver, privateKey) {
  if (!Object.prototype.hasOwnProperty.call(receiver, privateKey)) {
    throw new TypeError("attempted to use private field on non-instance");
  }

  return receiver;
}

/***/ }),

/***/ "../../node_modules/@polkadot/rpc-provider/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js":
/*!**********************************************************************************************************************!*\
  !*** ../../node_modules/@polkadot/rpc-provider/node_modules/@babel/runtime/helpers/esm/classPrivateFieldLooseKey.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ _classPrivateFieldKey)
/* harmony export */ });
var id = 0;
function _classPrivateFieldKey(name) {
  return "__private_" + id++ + "_" + name;
}

/***/ }),

/***/ "../../node_modules/@polkadot/util/format/formatDate.js":
/*!**************************************************************!*\
  !*** ../../node_modules/@polkadot/util/format/formatDate.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "formatDate": () => (/* binding */ formatDate)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/** @internal */
function zeroPad(value) {
  return value.toString().padStart(2, '0');
}

function formatDate(date) {
  const year = date.getFullYear().toString();
  const month = zeroPad(date.getMonth() + 1);
  const day = zeroPad(date.getDate());
  const hour = zeroPad(date.getHours());
  const minute = zeroPad(date.getMinutes());
  const second = zeroPad(date.getSeconds());
  return `${year}-${month}-${day} ${hour}:${minute}:${second}`;
}

/***/ }),

/***/ "../../node_modules/@polkadot/util/is/object.js":
/*!******************************************************!*\
  !*** ../../node_modules/@polkadot/util/is/object.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "isObject": () => (/* binding */ isObject)
/* harmony export */ });
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

/**
 * @name isObject
 * @summary Tests for an `object`.
 * @description
 * Checks to see if the input value is a JavaScript object.
 * @example
 * <BR>
 *
 * ```javascript
 * import { isObject } from '@polkadot/util';
 *
 * isObject({}); // => true
 * isObject('something'); // => false
 * ```
 */
function isObject(value) {
  return typeof value === 'object';
}

/***/ }),

/***/ "../../node_modules/@polkadot/util/logger.js":
/*!***************************************************!*\
  !*** ../../node_modules/@polkadot/util/logger.js ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "loggerFormat": () => (/* binding */ loggerFormat),
/* harmony export */   "logger": () => (/* binding */ logger)
/* harmony export */ });
/* harmony import */ var _format_formatDate_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./format/formatDate.js */ "../../node_modules/@polkadot/util/format/formatDate.js");
/* harmony import */ var _is_bn_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./is/bn.js */ "../../node_modules/@polkadot/util/is/bn.js");
/* harmony import */ var _is_buffer_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./is/buffer.js */ "../../node_modules/@polkadot/util/is/buffer.js");
/* harmony import */ var _is_function_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./is/function.js */ "../../node_modules/@polkadot/util/is/function.js");
/* harmony import */ var _is_object_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is/object.js */ "../../node_modules/@polkadot/util/is/object.js");
/* harmony import */ var _is_u8a_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./is/u8a.js */ "../../node_modules/@polkadot/util/is/u8a.js");
/* harmony import */ var _u8a_toHex_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./u8a/toHex.js */ "../../node_modules/@polkadot/util/u8a/toHex.js");
/* harmony import */ var _u8a_toU8a_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./u8a/toU8a.js */ "../../node_modules/@polkadot/util/u8a/toU8a.js");
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0








const logTo = {
  debug: 'log',
  error: 'error',
  log: 'log',
  warn: 'warn'
};

function formatOther(value) {
  if (value && (0,_is_object_js__WEBPACK_IMPORTED_MODULE_0__.isObject)(value) && value.constructor === Object) {
    return Object.keys(value).reduce((result, key) => {
      result[key] = loggerFormat(value[key]);
      return result;
    }, {});
  }

  return value;
}

function loggerFormat(value) {
  if (Array.isArray(value)) {
    return value.map(loggerFormat);
  } else if ((0,_is_bn_js__WEBPACK_IMPORTED_MODULE_1__.isBn)(value)) {
    return value.toString();
  } else if ((0,_is_u8a_js__WEBPACK_IMPORTED_MODULE_2__.isU8a)(value) || (0,_is_buffer_js__WEBPACK_IMPORTED_MODULE_3__.isBuffer)(value)) {
    return (0,_u8a_toHex_js__WEBPACK_IMPORTED_MODULE_4__.u8aToHex)((0,_u8a_toU8a_js__WEBPACK_IMPORTED_MODULE_5__.u8aToU8a)(value));
  }

  return formatOther(value);
}

function apply(log, type, values, maxSize = -1) {
  if (values.length === 1 && (0,_is_function_js__WEBPACK_IMPORTED_MODULE_6__.isFunction)(values[0])) {
    const fnResult = values[0]();
    return apply(log, type, Array.isArray(fnResult) ? fnResult : [fnResult], maxSize);
  }

  console[logTo[log]]((0,_format_formatDate_js__WEBPACK_IMPORTED_MODULE_7__.formatDate)(new Date()), type, ...values.map(loggerFormat).map(v => {
    if (maxSize <= 0) {
      return v;
    }

    const r = `${v}`;
    return r.length < maxSize ? v : `${r.substr(0, maxSize)} ...`;
  }));
}

function noop() {// noop
}

function parseEnv(type) {
  const env = ( true ? ({"env":{"WS_URL":undefined}}) : 0).env || {};
  const maxSize = parseInt(env.DEBUG_MAX || '-1', 10);
  let isDebugOn = false;
  (env.DEBUG || '').toLowerCase().split(',').forEach(e => {
    if (!!e && (e === '*' || type === e || e.endsWith('*') && type.startsWith(e.slice(0, -1)))) {
      isDebugOn = true;
    }

    if (!!e && e.startsWith('-') && (type === e.slice(1) || e.endsWith('*') && type.startsWith(e.slice(1, -1)))) {
      isDebugOn = false;
    }
  });
  return [isDebugOn, isNaN(maxSize) ? -1 : maxSize];
}
/**
 * @name Logger
 * @summary Creates a consistent log interface for messages
 * @description
 * Returns a `Logger` that has `.log`, `.error`, `.warn` and `.debug` (controlled with environment `DEBUG=typeA,typeB`) methods. Logging is done with a consistent prefix (type of logger, date) followed by the actual message using the underlying console.
 * @example
 * <BR>
 *
 * ```javascript
 * import { logger } from '@polkadot';
 *
 * const l = logger('test');
 * ```
 */


function logger(_type) {
  const type = `${_type.toUpperCase()}:`.padStart(16);
  const [isDebug, maxSize] = parseEnv(_type.toLowerCase());
  return {
    debug: isDebug ? (...values) => apply('debug', type, values, maxSize) : noop,
    error: (...values) => apply('error', type, values),
    log: (...values) => apply('log', type, values),
    noop,
    warn: (...values) => apply('warn', type, values)
  };
}

/***/ }),

/***/ "../../node_modules/@polkadot/util/stringify.js":
/*!******************************************************!*\
  !*** ../../node_modules/@polkadot/util/stringify.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "stringify": () => (/* binding */ stringify)
/* harmony export */ });
/* harmony import */ var _is_bigInt_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./is/bigInt.js */ "../../node_modules/@polkadot/util/is/bigInt.js");
// Copyright 2017-2021 @polkadot/util authors & contributors
// SPDX-License-Identifier: Apache-2.0

function stringify(args, space) {
  return JSON.stringify(args, (_, value) => (0,_is_bigInt_js__WEBPACK_IMPORTED_MODULE_0__.isBigInt)(value) ? value.toString() : value, space);
}

/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/src/compat-browser.js":
/*!*************************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/src/compat-browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "net": () => (/* binding */ net),
/* harmony export */   "Worker": () => (/* binding */ Worker),
/* harmony export */   "workerOnMessage": () => (/* binding */ workerOnMessage),
/* harmony export */   "workerOnError": () => (/* binding */ workerOnError),
/* harmony export */   "postMessage": () => (/* binding */ postMessage),
/* harmony export */   "setOnMessage": () => (/* binding */ setOnMessage)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Overrides `compat-nodejs.js` when in a browser.

const net = null;
const Worker = typeof window != 'undefined' ? window.Worker : null;
const workerOnMessage = (worker, callback) => { worker.onmessage = (event) => callback(event.data) };
const workerOnError = (worker, callback) => { worker.onerror = callback; };  // TODO: unclear if the parameter of the callback is same as with NodeJS
const postMessage = (msg) => self.postMessage(msg);
const setOnMessage = (callback) => { self.onmessage = (event) => callback(event.data) };


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/src/health.js":
/*!*****************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/src/health.js ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "healthChecker": () => (/* binding */ healthChecker)
/* harmony export */ });
// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.

// Creates a new health checker.
//
// The role of the health checker is to report to the user the health of a smoldot chain.
//
// In order to use it, start by creating a health checker, and call `setSendJsonRpc` to set the
// way to send a JSON-RPC request to a chain. The health checker is disabled by default. Use
// `start()` in order to start the health checks. The `start()` function must be passed a callback called
// when an update to the health of the node is available.
//
// In order to send a JSON-RPC request to the chain, you **must** use the `sendJsonRpc` function
// of the health checker. The health checker rewrites the `id` of the requests it receives.
//
// When the chain send a JSON-RPC response, it must be passed to `responsePassThrough()`. This
// function intercepts the responses destined to the requests that have been emitted by the health
// checker and returns `null`. If the response doesn't concern the health checker, the response is
// simply returned by the function.
//
// # How it works
//
// The health checker periodically calls the `system_health` JSON-RPC call in order to determine
// the health of the chain.
//
// In addition to this, as long as the health check reports that `isSyncing` is `true`, the
// health checker also maintains a subscription to new best blocks using `chain_subscribeNewHeads`.
// Whenever a new block is notified, a health check is performed immediately in order to determine
// whether `isSyncing` has changed to `false`.
//
// Thanks to this subscription, the latency of the report of the switch from `isSyncing: true` to
// `isSyncing: false` is very low.
//
function healthChecker() {
    // `null` if health checker is not started.
    let checker = null;
    let sendJsonRpc = null;

    return {
        setSendJsonRpc: (cb) => {
            sendJsonRpc = cb;
        },

        start: (healthCallback) => {
            if (checker !== null)
                throw new Error("Can't start the health checker multiple times in parallel");
            if (!sendJsonRpc)
                throw new Error("setSendJsonRpc must be called before starting the health checks");

            checker = {
                healthCallback,
                currentHealthCheckId: null,
                currentHealthTimeout: null,
                currentSubunsubRequestId: null,
                currentSubscriptionId: null,
                isSyncing: false,
                nextRequestId: 0,

                sendJsonRpc: function (request) {
                    // Replace the `id` in the request to prefix the request ID with `extern:`.
                    let parsedRequest;
                    try {
                        parsedRequest = JSON.parse(request);
                    } catch (err) {
                        return;
                    };

                    if (parsedRequest.id) {
                        const newId = 'extern:' + JSON.stringify(parsedRequest.id);
                        parsedRequest.id = newId;
                    }

                    sendJsonRpc(JSON.stringify(parsedRequest));
                },

                responsePassThrough: function (jsonRpcResponse) {
                    let parsedResponse;
                    try {
                        parsedResponse = JSON.parse(jsonRpcResponse);
                    } catch (err) {
                        return jsonRpcResponse;
                    };

                    // Check whether response is a response to `system_health`.
                    if (parsedResponse.id && this.currentHealthCheckId == parsedResponse.id) {
                        this.currentHealthCheckId = null;

                        // Check whether query was successful. It is possible for queries to fail for
                        // various reasons, such as the client being overloaded.
                        if (!parsedResponse.result) {
                            this.update();
                            return null;
                        }

                        this.healthCallback(parsedResponse.result);
                        this.isSyncing = parsedResponse.result.isSyncing;
                        this.update();
                        return null;
                    }

                    // Check whether response is a response to the subscription or unsubscription.
                    if (parsedResponse.id && this.currentSubunsubRequestId == parsedResponse.id) {
                        this.currentSubunsubRequestId = null;

                        // Check whether query was successful. It is possible for queries to fail for
                        // various reasons, such as the client being overloaded.
                        if (!parsedResponse.result) {
                            this.update();
                            return null;
                        }

                        if (this.currentSubscriptionId)
                            this.currentSubscriptionId = null;
                        else
                            this.currentSubscriptionId = parsedResponse.result;

                        this.update();
                        return null;
                    }

                    // Check whether response is a notification to a subscription.
                    if (parsedResponse.params && this.currentSubscriptionId &&
                        parsedResponse.params.subscription == this.currentSubscriptionId) {
                        // Note that after a successful subscription, a notification containing
                        // the current best block is always returned. Considering that a
                        // subscription is performed in response to a health check, calling
                        // `startHealthCheck()` here will lead to a second health check.
                        // It might seem redundant to perform two health checks in a quick
                        // succession, but doing so doesn't lead to any problem, and it is
                        // actually possible for the health to have changed in between as the
                        // current best block might have been updated during the subscription
                        // request.
                        this.startHealthCheck();
                        this.update();
                        return null;
                    }

                    // Response doesn't concern us.
                    if (parsedResponse.id) {
                        // Need to remove the `extern:` prefix.
                        if (!parsedResponse.id.startsWith('extern:'))
                            throw new Error('State inconsistency in health checker');
                        const newId = JSON.parse(parsedResponse.id.slice('extern:'.length));
                        parsedResponse.id = newId;
                    }

                    return JSON.stringify(parsedResponse);
                },

                update: function () {
                    if (!this.currentHealthTimeout) {
                        this.currentHealthTimeout = setTimeout(() => {
                            this.currentHealthTimeout = null;
                            this.startHealthCheck();
                        }, 10000);
                    }

                    if (this.isSyncing && !this.currentSubscriptionId && !this.currentSubunsubRequestId)
                        this.startSubscription();
                    if (!this.isSyncing && this.currentSubscriptionId && !this.currentSubunsubRequestId)
                        this.endSubscription();
                },

                startHealthCheck: function () {
                    if (this.currentHealthCheckId)
                        throw new Error('Internal error in health checker');
                    if (this.currentHealthTimeout) {
                        clearTimeout(this.currentHealthTimeout);
                        this.currentHealthTimeout = null;
                    }
                    this.currentHealthCheckId = "health-checker:" + this.nextRequestId;
                    this.nextRequestId += 1;
                    sendJsonRpc(JSON.stringify({
                        jsonrpc: "2.0",
                        id: this.currentHealthCheckId,
                        method: 'system_health',
                        params: [],
                    }));
                },

                startSubscription: function () {
                    if (this.currentSubunsubRequestId || this.currentSubscriptionId)
                        throw new Error('Internal error in health checker');
                    this.currentSubunsubRequestId = "health-checker:" + this.nextRequestId;
                    this.nextRequestId += 1;
                    sendJsonRpc(JSON.stringify({
                        jsonrpc: "2.0",
                        id: this.currentSubunsubRequestId,
                        method: 'chain_subscribeNewHeads',
                        params: [],
                    }));
                },

                endSubscription: function () {
                    if (this.currentSubunsubRequestId || !this.currentSubscriptionId)
                        throw new Error('Internal error in health checker');
                    this.currentSubunsubRequestId = "health-checker:" + this.nextRequestId;
                    this.nextRequestId += 1;
                    sendJsonRpc(JSON.stringify({
                        jsonrpc: "2.0",
                        id: this.currentSubunsubRequestId,
                        method: 'chain_unsubscribeNewHeads',
                        params: [this.currentSubscriptionId],
                    }));
                },

                destroy: function () {
                    if (this.currentHealthTimeout) {
                        clearTimeout(this.currentHealthTimeout);
                        this.currentHealthTimeout = null;
                    }
                }
            };

            checker.startHealthCheck();
        },
        stop: () => {
            if (checker === null)
                return; // Already stopped.
            checker.destroy();
            checker = null;
        },
        sendJsonRpc: (request) => {
            if (!sendJsonRpc)
                throw new Error("setSendJsonRpc must be called before sending requests");
            if (checker === null)
                sendJsonRpc(request);
            else
                checker.sendJsonRpc(request);
        },
        responsePassThrough: (jsonRpcResponse) => {
            if (checker === null)
                return jsonRpcResponse;
            return checker.responsePassThrough(jsonRpcResponse);
        },
    };
}


/***/ }),

/***/ "../../node_modules/@substrate/smoldot-light/src/index.js":
/*!****************************************************************!*\
  !*** ../../node_modules/@substrate/smoldot-light/src/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "healthChecker": () => (/* reexport safe */ _health_js__WEBPACK_IMPORTED_MODULE_1__.healthChecker),
/* harmony export */   "AlreadyDestroyedError": () => (/* binding */ AlreadyDestroyedError),
/* harmony export */   "AddChainError": () => (/* binding */ AddChainError),
/* harmony export */   "JsonRpcDisabledError": () => (/* binding */ JsonRpcDisabledError),
/* harmony export */   "CrashError": () => (/* binding */ CrashError),
/* harmony export */   "start": () => (/* binding */ start)
/* harmony export */ });
/* harmony import */ var _compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./compat-nodejs.js */ "../../node_modules/@substrate/smoldot-light/src/compat-browser.js");
/* harmony import */ var _health_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./health.js */ "../../node_modules/@substrate/smoldot-light/src/health.js");
// Smoldot
// Copyright (C) 2019-2021  Parity Technologies (UK) Ltd.
// SPDX-License-Identifier: GPL-3.0-or-later WITH Classpath-exception-2.0

// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.




class AlreadyDestroyedError extends Error {
}

class AddChainError extends Error {
  constructor(message) {
    super(message);
  }
}

class JsonRpcDisabledError extends Error {
}

class CrashError extends Error {
  constructor(message) {
    super(message);
  }
}

function start(config) {
  config = config || {};

  const logCallback = config.logCallback || ((level, target, message) => {
    if (level <= 1) {
      console.error("[" + target + "]", message);
    } else if (level == 2) {
      console.warn("[" + target + "]", message);
    } else if (level == 3) {
      console.info("[" + target + "]", message);
    } else if (level == 4) {
      console.debug("[" + target + "]", message);
    } else {
      console.trace("[" + target + "]", message);
    }
  });

  // The actual execution of Smoldot is performed in a worker thread.
  //
  // The line of code below (`new Worker(...)`) is designed to hopefully work across all
  // platforms and bundlers. See the README.md for more context.
  const worker = new _compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__.Worker(new URL(/* worker import */ __webpack_require__.p + __webpack_require__.u("vendors-node_modules_substrate_smoldot-light_src_worker_js"), __webpack_require__.b));
  let workerError = null;

  // Whenever an `addChain` or `removeChain` message is sent to the worker, a corresponding entry
  // is pushed to this array. The worker needs to send back a confirmation, which pops the first
  // element of this array. In the case of `addChain`, additional fields are stored in this array
  // to finish the initialization of the chain.
  let pendingConfirmations = [];

  // For each chain that is currently running, contains the callback to use to send back JSON-RPC
  // responses corresponding to this chain.
  // Entries are instantly removed when the user desires to remove a chain even before the worker
  // has confirmed the removal. Doing so avoids a race condition where the worker sends back a
  // JSON-RPC response even though we've already sent a `removeChain` message to it.
  let chainsJsonRpcCallbacks = new Map();

  // The worker periodically sends a message of kind 'livenessPing' in order to notify that it is
  // still alive.
  // If this liveness ping isn't received for a long time, an error is reported in the logs.
  // The first check is delayed in order to account for the fact that the worker has to perform
  // an expensive initialization step when initializing the Wasm VM.
  let livenessTimeout = null;
  const resetLivenessTimeout = () => {
    if (livenessTimeout !== null)
      clearTimeout(livenessTimeout);
    livenessTimeout = setTimeout(() => {
      livenessTimeout = null;
      console.warn(
        "Smoldot appears unresponsive. Please open an issue at " +
        "https://github.com/paritytech/smoldot/issues. If you have a debugger available, " +
        "please pause execution, generate a stack trace of the thread that isn't the main " +
        "execution thread, and paste it in the issue. Please also include any other log found " +
        "in the console or elsewhere."
      );
    }, 10000);
  };
  setTimeout(() => resetLivenessTimeout(), 15000);

  // The worker can send us messages whose type is identified through a `kind` field.
  (0,_compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__.workerOnMessage)(worker, (message) => {
    if (message.kind == 'jsonrpc') {
      const cb = chainsJsonRpcCallbacks.get(message.chainId);
      if (cb) cb(message.data);

    } else if (message.kind == 'chainAddedOk') {
      const expected = pendingConfirmations.shift();
      let chainId = message.chainId; // Later set to null when the chain is removed.

      if (chainsJsonRpcCallbacks.has(chainId)) // Sanity check.
        throw 'Unexpected reuse of a chain ID';
      chainsJsonRpcCallbacks.set(chainId, expected.jsonRpcCallback);

      // `expected` was pushed by the `addChain` method.
      // Resolve the promise that `addChain` returned to the user.
      expected.resolve({
        sendJsonRpc: (request) => {
          if (workerError)
            throw workerError;
          if (chainId === null)
            throw new AlreadyDestroyedError();
          if (!chainsJsonRpcCallbacks.has(chainId))
            throw new JsonRpcDisabledError();
          worker.postMessage({ ty: 'request', request, chainId });
        },
        remove: () => {
          if (workerError)
            throw workerError;
          if (chainId === null)
            throw new AlreadyDestroyedError();
          pendingConfirmations.push({ ty: 'chainRemoved', chainId });
          worker.postMessage({ ty: 'removeChain', chainId });
          // Because the `removeChain` message is asynchronous, it is possible for a JSON-RPC
          // response concerning that `chainId` to arrive after the `remove` function has
          // returned. We solve that by removing the callback immediately.
          chainsJsonRpcCallbacks.delete(chainId);
          chainId = null;
        },
        // Hacky internal method that later lets us access the `chainId` of this chain for
        // implementation reasons.
        __internal_smoldot_id: () => chainId,
      });

    } else if (message.kind == 'chainAddedErr') {
      const expected = pendingConfirmations.shift();
      // `expected` was pushed by the `addChain` method.
      // Reject the promise that `addChain` returned to the user.
      expected.reject(new AddChainError(message.error));

    } else if (message.kind == 'chainRemoved') {
      pendingConfirmations.shift();

    } else if (message.kind == 'log') {
      logCallback(message.level, message.target, message.message);

    } else if (message.kind == 'livenessPing') {
      resetLivenessTimeout();

    } else {
      console.error('Unknown message type', message);
    }
  });

  (0,_compat_nodejs_js__WEBPACK_IMPORTED_MODULE_0__.workerOnError)(worker, (error) => {
    // A worker error should only happen in case of a critical error as the result of a bug
    // somewhere. Consequently, nothing is really in place to cleanly report the error.
    console.error(
      "Smoldot has panicked. This is a bug in smoldot. Please open an issue at " +
      "https://github.com/paritytech/smoldot/issues with the following message:"
    );
    console.error(error);
    workerError = new CrashError(error.toString());

    // Reject all promises returned by `addChain`.
    for (var pending of pendingConfirmations) {
      if (pending.ty == 'chainAdded')
        pending.reject(workerError);
    }
    pendingConfirmations = [];
  });

  // The first message expected by the worker contains the configuration.
  worker.postMessage({
    // Maximum level of log entries sent by the client.
    // 0 = Logging disabled, 1 = Error, 2 = Warn, 3 = Info, 4 = Debug, 5 = Trace
    maxLogLevel: config.maxLogLevel || 3,
    forbidTcp: config.forbidTcp,
    forbidWs: config.forbidWs,
    forbidWss: config.forbidWss,
  });

  return {
    addChain: (options) => {
      if (workerError)
        throw workerError;

      let potentialRelayChainsIds = [];
      if (!!options.potentialRelayChains) {
        for (const chain of options.potentialRelayChains) {
          // The content of `options.potentialRelayChains` are supposed to be chains earlier
          // returned by `addChain`. The hacky `__internal_smoldot_id` method lets us obtain the
          // internal ID of these chains.
          const id = chain.__internal_smoldot_id();
          if (id === null) // It is possible for `id` to be null if it has earlier been removed.
            continue;
          potentialRelayChainsIds.push(id);
        }
      }

      // Build a promise that will be resolved or rejected after the chain has been added.
      let chainAddedPromiseResolve;
      let chainAddedPromiseReject;
      const chainAddedPromise = new Promise((resolve, reject) => {
        chainAddedPromiseResolve = resolve;
        chainAddedPromiseReject = reject;
      });

      pendingConfirmations.push({
        ty: 'chainAdded',
        reject: chainAddedPromiseReject,
        resolve: chainAddedPromiseResolve,
        jsonRpcCallback: options.jsonRpcCallback,
      });

      worker.postMessage({
        ty: 'addChain',
        chainSpec: options.chainSpec,
        potentialRelayChains: potentialRelayChainsIds,
        jsonRpcRunning: !!options.jsonRpcCallback,
      });

      return chainAddedPromise;
    },
    terminate: () => {
      worker.terminate();
      if (!workerError)
        workerError = new AlreadyDestroyedError();
    }
  }
}


/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfcG9sa2Fkb3RfcnBjLXByb3ZpZGVyX2NvZGVyX2luZGV4X2pzLW5vZGVfbW9kdWxlc19wb2xrYWRvdF91dGlsX2xvZ2dlcl9qLWEzZjVkYy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRztBQUNGO0FBQzlGO0FBQ0E7QUFDb0Y7O0FBRXBGO0FBQ0EsTUFBTSwyREFBVztBQUNqQjtBQUNBOztBQUVBLHlCQUF5Qix3REFBUSwySEFBMkgseURBQVMsT0FBTyxHQUFHO0FBQy9LOztBQUVBLGtEQUFrRCx5QkFBeUI7QUFDM0U7QUFDQTs7O0FBR0EsdUJBQXVCLGdHQUEwQjs7QUFFMUM7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLElBQUksc0RBQU07QUFDVixJQUFJLHNEQUFNO0FBQ1YsNEJBQTRCLDJEQUFXLHNCQUFzQiwyREFBVztBQUN4RSxJQUFJLHNEQUFNLENBQUMsd0RBQVEsb0NBQW9DLHdEQUFRLGtDQUFrQyx3REFBUTs7QUFFekc7O0FBRUEsSUFBSSxzREFBTSxFQUFFLDJEQUFXOztBQUV2QjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLFdBQVcseURBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBLFlBQVksaUdBQTJCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLGlHQUEyQjtBQUN0Qzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IseUJBQXlCLEtBQUssSUFBSSxRQUFRLEVBQUUsc0JBQXNCO0FBQ2xFO0FBQ0E7O0FBRUE7Ozs7Ozs7Ozs7Ozs7O0FDNUVlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDTkE7QUFDZTtBQUNmO0FBQ0E7Ozs7Ozs7Ozs7Ozs7O0FDSEE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7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Q0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL0BzdWJzdHJhdGUvYnVybnIvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC9ycGMtcHJvdmlkZXIvY29kZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vQHN1YnN0cmF0ZS9idXJuci8uLi8uLi9ub2RlX21vZHVsZXMvQHBvbGthZG90L3JwYy1wcm92aWRlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2UuanMiLCJ3ZWJwYWNrOi8vQHN1YnN0cmF0ZS9idXJuci8uLi8uLi9ub2RlX21vZHVsZXMvQHBvbGthZG90L3JwYy1wcm92aWRlci9ub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NQcml2YXRlRmllbGRMb29zZUtleS5qcyIsIndlYnBhY2s6Ly9Ac3Vic3RyYXRlL2J1cm5yLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvdXRpbC9mb3JtYXQvZm9ybWF0RGF0ZS5qcyIsIndlYnBhY2s6Ly9Ac3Vic3RyYXRlL2J1cm5yLy4uLy4uL25vZGVfbW9kdWxlcy9AcG9sa2Fkb3QvdXRpbC9pcy9vYmplY3QuanMiLCJ3ZWJwYWNrOi8vQHN1YnN0cmF0ZS9idXJuci8uLi8uLi9ub2RlX21vZHVsZXMvQHBvbGthZG90L3V0aWwvbG9nZ2VyLmpzIiwid2VicGFjazovL0BzdWJzdHJhdGUvYnVybnIvLi4vLi4vbm9kZV9tb2R1bGVzL0Bwb2xrYWRvdC91dGlsL3N0cmluZ2lmeS5qcyIsIndlYnBhY2s6Ly9Ac3Vic3RyYXRlL2J1cm5yLy4uLy4uL25vZGVfbW9kdWxlcy9Ac3Vic3RyYXRlL3Ntb2xkb3QtbGlnaHQvc3JjL2NvbXBhdC1icm93c2VyLmpzIiwid2VicGFjazovL0BzdWJzdHJhdGUvYnVybnIvLi4vLi4vbm9kZV9tb2R1bGVzL0BzdWJzdHJhdGUvc21vbGRvdC1saWdodC9zcmMvaGVhbHRoLmpzIiwid2VicGFjazovL0BzdWJzdHJhdGUvYnVybnIvLi4vLi4vbm9kZV9tb2R1bGVzL0BzdWJzdHJhdGUvc21vbGRvdC1saWdodC9zcmMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9jbGFzc1ByaXZhdGVGaWVsZExvb3NlQmFzZSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NQcml2YXRlRmllbGRMb29zZUJhc2VcIjtcbmltcG9ydCBfY2xhc3NQcml2YXRlRmllbGRMb29zZUtleSBmcm9tIFwiQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vY2xhc3NQcml2YXRlRmllbGRMb29zZUtleVwiO1xuLy8gQ29weXJpZ2h0IDIwMTctMjAyMSBAcG9sa2Fkb3QvcnBjLXByb3ZpZGVyIGF1dGhvcnMgJiBjb250cmlidXRvcnNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5pbXBvcnQgeyBhc3NlcnQsIGlzTnVtYmVyLCBpc1N0cmluZywgaXNVbmRlZmluZWQsIHN0cmluZ2lmeSB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsJztcblxuZnVuY3Rpb24gZm9ybWF0RXJyb3JEYXRhKGRhdGEpIHtcbiAgaWYgKGlzVW5kZWZpbmVkKGRhdGEpKSB7XG4gICAgcmV0dXJuICcnO1xuICB9XG5cbiAgY29uc3QgZm9ybWF0dGVkID0gYDogJHtpc1N0cmluZyhkYXRhKSA/IGRhdGEucmVwbGFjZSgvRXJyb3JcXChcIi9nLCAnJykucmVwbGFjZSgvXFwoXCIvZywgJygnKS5yZXBsYWNlKC9cIlxcKS9nLCAnKScpLnJlcGxhY2UoL1xcKC9nLCAnLCAnKS5yZXBsYWNlKC9cXCkvZywgJycpIDogc3RyaW5naWZ5KGRhdGEpfWA7IC8vIFdlIG5lZWQgc29tZSBzb3J0IG9mIGN1dC1vZmYgaGVyZSBzaW5jZSB0aGVzZSBjYW4gYmUgdmVyeSBsYXJnZSBhbmRcbiAgLy8gdmVyeSBuZXN0ZWQsIHBpY2sgYSBudW1iZXIgYW5kIHRyaW0gdGhlIHJlc3VsdCBkaXNwbGF5IHRvIGl0XG5cbiAgcmV0dXJuIGZvcm1hdHRlZC5sZW5ndGggPD0gMjU2ID8gZm9ybWF0dGVkIDogYCR7Zm9ybWF0dGVkLnN1YnN0cigwLCAyNTUpfeKApmA7XG59XG4vKiogQGludGVybmFsICovXG5cblxudmFyIF9pZCA9IC8qI19fUFVSRV9fKi9fY2xhc3NQcml2YXRlRmllbGRMb29zZUtleShcImlkXCIpO1xuXG5leHBvcnQgY2xhc3MgUnBjQ29kZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgX2lkLCB7XG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiAwXG4gICAgfSk7XG4gIH1cblxuICBkZWNvZGVSZXNwb25zZShyZXNwb25zZSkge1xuICAgIGFzc2VydChyZXNwb25zZSwgJ0VtcHR5IHJlc3BvbnNlIG9iamVjdCByZWNlaXZlZCcpO1xuICAgIGFzc2VydChyZXNwb25zZS5qc29ucnBjID09PSAnMi4wJywgJ0ludmFsaWQganNvbnJwYyBmaWVsZCBpbiBkZWNvZGVkIG9iamVjdCcpO1xuICAgIGNvbnN0IGlzU3Vic2NyaXB0aW9uID0gIWlzVW5kZWZpbmVkKHJlc3BvbnNlLnBhcmFtcykgJiYgIWlzVW5kZWZpbmVkKHJlc3BvbnNlLm1ldGhvZCk7XG4gICAgYXNzZXJ0KGlzTnVtYmVyKHJlc3BvbnNlLmlkKSB8fCBpc1N1YnNjcmlwdGlvbiAmJiAoaXNOdW1iZXIocmVzcG9uc2UucGFyYW1zLnN1YnNjcmlwdGlvbikgfHwgaXNTdHJpbmcocmVzcG9uc2UucGFyYW1zLnN1YnNjcmlwdGlvbikpLCAnSW52YWxpZCBpZCBmaWVsZCBpbiBkZWNvZGVkIG9iamVjdCcpO1xuXG4gICAgdGhpcy5fY2hlY2tFcnJvcihyZXNwb25zZS5lcnJvcik7XG5cbiAgICBhc3NlcnQoIWlzVW5kZWZpbmVkKHJlc3BvbnNlLnJlc3VsdCkgfHwgaXNTdWJzY3JpcHRpb24sICdObyByZXN1bHQgZm91bmQgaW4gSnNvblJwYyByZXNwb25zZScpO1xuXG4gICAgaWYgKGlzU3Vic2NyaXB0aW9uKSB7XG4gICAgICB0aGlzLl9jaGVja0Vycm9yKHJlc3BvbnNlLnBhcmFtcy5lcnJvcik7XG5cbiAgICAgIHJldHVybiByZXNwb25zZS5wYXJhbXMucmVzdWx0O1xuICAgIH1cblxuICAgIHJldHVybiByZXNwb25zZS5yZXN1bHQ7XG4gIH1cblxuICBlbmNvZGVKc29uKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeSh0aGlzLmVuY29kZU9iamVjdChtZXRob2QsIHBhcmFtcykpO1xuICB9XG5cbiAgZW5jb2RlT2JqZWN0KG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlkOiArK19jbGFzc1ByaXZhdGVGaWVsZExvb3NlQmFzZSh0aGlzLCBfaWQpW19pZF0sXG4gICAgICBqc29ucnBjOiAnMi4wJyxcbiAgICAgIG1ldGhvZCxcbiAgICAgIHBhcmFtc1xuICAgIH07XG4gIH1cblxuICBnZXRJZCgpIHtcbiAgICByZXR1cm4gX2NsYXNzUHJpdmF0ZUZpZWxkTG9vc2VCYXNlKHRoaXMsIF9pZClbX2lkXTtcbiAgfVxuXG4gIF9jaGVja0Vycm9yKGVycm9yKSB7XG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGNvZGUsXG4gICAgICAgIGRhdGEsXG4gICAgICAgIG1lc3NhZ2VcbiAgICAgIH0gPSBlcnJvcjtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtjb2RlfTogJHttZXNzYWdlfSR7Zm9ybWF0RXJyb3JEYXRhKGRhdGEpfWApO1xuICAgIH1cbiAgfVxuXG59IiwiZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkQmFzZShyZWNlaXZlciwgcHJpdmF0ZUtleSkge1xuICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChyZWNlaXZlciwgcHJpdmF0ZUtleSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHVzZSBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtcbiAgfVxuXG4gIHJldHVybiByZWNlaXZlcjtcbn0iLCJ2YXIgaWQgPSAwO1xuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gX2NsYXNzUHJpdmF0ZUZpZWxkS2V5KG5hbWUpIHtcbiAgcmV0dXJuIFwiX19wcml2YXRlX1wiICsgaWQrKyArIFwiX1wiICsgbmFtZTtcbn0iLCIvLyBDb3B5cmlnaHQgMjAxNy0yMDIxIEBwb2xrYWRvdC91dGlsIGF1dGhvcnMgJiBjb250cmlidXRvcnNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5cbi8qKiBAaW50ZXJuYWwgKi9cbmZ1bmN0aW9uIHplcm9QYWQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgJzAnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZvcm1hdERhdGUoZGF0ZSkge1xuICBjb25zdCB5ZWFyID0gZGF0ZS5nZXRGdWxsWWVhcigpLnRvU3RyaW5nKCk7XG4gIGNvbnN0IG1vbnRoID0gemVyb1BhZChkYXRlLmdldE1vbnRoKCkgKyAxKTtcbiAgY29uc3QgZGF5ID0gemVyb1BhZChkYXRlLmdldERhdGUoKSk7XG4gIGNvbnN0IGhvdXIgPSB6ZXJvUGFkKGRhdGUuZ2V0SG91cnMoKSk7XG4gIGNvbnN0IG1pbnV0ZSA9IHplcm9QYWQoZGF0ZS5nZXRNaW51dGVzKCkpO1xuICBjb25zdCBzZWNvbmQgPSB6ZXJvUGFkKGRhdGUuZ2V0U2Vjb25kcygpKTtcbiAgcmV0dXJuIGAke3llYXJ9LSR7bW9udGh9LSR7ZGF5fSAke2hvdXJ9OiR7bWludXRlfToke3NlY29uZH1gO1xufSIsIi8vIENvcHlyaWdodCAyMDE3LTIwMjEgQHBvbGthZG90L3V0aWwgYXV0aG9ycyAmIGNvbnRyaWJ1dG9yc1xuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEFwYWNoZS0yLjBcblxuLyoqXG4gKiBAbmFtZSBpc09iamVjdFxuICogQHN1bW1hcnkgVGVzdHMgZm9yIGFuIGBvYmplY3RgLlxuICogQGRlc2NyaXB0aW9uXG4gKiBDaGVja3MgdG8gc2VlIGlmIHRoZSBpbnB1dCB2YWx1ZSBpcyBhIEphdmFTY3JpcHQgb2JqZWN0LlxuICogQGV4YW1wbGVcbiAqIDxCUj5cbiAqXG4gKiBgYGBqYXZhc2NyaXB0XG4gKiBpbXBvcnQgeyBpc09iamVjdCB9IGZyb20gJ0Bwb2xrYWRvdC91dGlsJztcbiAqXG4gKiBpc09iamVjdCh7fSk7IC8vID0+IHRydWVcbiAqIGlzT2JqZWN0KCdzb21ldGhpbmcnKTsgLy8gPT4gZmFsc2VcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3QodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCc7XG59IiwiLy8gQ29weXJpZ2h0IDIwMTctMjAyMSBAcG9sa2Fkb3QvdXRpbCBhdXRob3JzICYgY29udHJpYnV0b3JzXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogQXBhY2hlLTIuMFxuaW1wb3J0IHsgZm9ybWF0RGF0ZSB9IGZyb20gXCIuL2Zvcm1hdC9mb3JtYXREYXRlLmpzXCI7XG5pbXBvcnQgeyBpc0JuIH0gZnJvbSBcIi4vaXMvYm4uanNcIjtcbmltcG9ydCB7IGlzQnVmZmVyIH0gZnJvbSBcIi4vaXMvYnVmZmVyLmpzXCI7XG5pbXBvcnQgeyBpc0Z1bmN0aW9uIH0gZnJvbSBcIi4vaXMvZnVuY3Rpb24uanNcIjtcbmltcG9ydCB7IGlzT2JqZWN0IH0gZnJvbSBcIi4vaXMvb2JqZWN0LmpzXCI7XG5pbXBvcnQgeyBpc1U4YSB9IGZyb20gXCIuL2lzL3U4YS5qc1wiO1xuaW1wb3J0IHsgdThhVG9IZXggfSBmcm9tIFwiLi91OGEvdG9IZXguanNcIjtcbmltcG9ydCB7IHU4YVRvVThhIH0gZnJvbSBcIi4vdThhL3RvVThhLmpzXCI7XG5jb25zdCBsb2dUbyA9IHtcbiAgZGVidWc6ICdsb2cnLFxuICBlcnJvcjogJ2Vycm9yJyxcbiAgbG9nOiAnbG9nJyxcbiAgd2FybjogJ3dhcm4nXG59O1xuXG5mdW5jdGlvbiBmb3JtYXRPdGhlcih2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgaXNPYmplY3QodmFsdWUpICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBPYmplY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLnJlZHVjZSgocmVzdWx0LCBrZXkpID0+IHtcbiAgICAgIHJlc3VsdFtrZXldID0gbG9nZ2VyRm9ybWF0KHZhbHVlW2tleV0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LCB7fSk7XG4gIH1cblxuICByZXR1cm4gdmFsdWU7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dnZXJGb3JtYXQodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLm1hcChsb2dnZXJGb3JtYXQpO1xuICB9IGVsc2UgaWYgKGlzQm4odmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSBpZiAoaXNVOGEodmFsdWUpIHx8IGlzQnVmZmVyKHZhbHVlKSkge1xuICAgIHJldHVybiB1OGFUb0hleCh1OGFUb1U4YSh2YWx1ZSkpO1xuICB9XG5cbiAgcmV0dXJuIGZvcm1hdE90aGVyKHZhbHVlKTtcbn1cblxuZnVuY3Rpb24gYXBwbHkobG9nLCB0eXBlLCB2YWx1ZXMsIG1heFNpemUgPSAtMSkge1xuICBpZiAodmFsdWVzLmxlbmd0aCA9PT0gMSAmJiBpc0Z1bmN0aW9uKHZhbHVlc1swXSkpIHtcbiAgICBjb25zdCBmblJlc3VsdCA9IHZhbHVlc1swXSgpO1xuICAgIHJldHVybiBhcHBseShsb2csIHR5cGUsIEFycmF5LmlzQXJyYXkoZm5SZXN1bHQpID8gZm5SZXN1bHQgOiBbZm5SZXN1bHRdLCBtYXhTaXplKTtcbiAgfVxuXG4gIGNvbnNvbGVbbG9nVG9bbG9nXV0oZm9ybWF0RGF0ZShuZXcgRGF0ZSgpKSwgdHlwZSwgLi4udmFsdWVzLm1hcChsb2dnZXJGb3JtYXQpLm1hcCh2ID0+IHtcbiAgICBpZiAobWF4U2l6ZSA8PSAwKSB7XG4gICAgICByZXR1cm4gdjtcbiAgICB9XG5cbiAgICBjb25zdCByID0gYCR7dn1gO1xuICAgIHJldHVybiByLmxlbmd0aCA8IG1heFNpemUgPyB2IDogYCR7ci5zdWJzdHIoMCwgbWF4U2l6ZSl9IC4uLmA7XG4gIH0pKTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHsvLyBub29wXG59XG5cbmZ1bmN0aW9uIHBhcnNlRW52KHR5cGUpIHtcbiAgY29uc3QgZW52ID0gKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyA/IHByb2Nlc3MgOiB7fSkuZW52IHx8IHt9O1xuICBjb25zdCBtYXhTaXplID0gcGFyc2VJbnQoZW52LkRFQlVHX01BWCB8fCAnLTEnLCAxMCk7XG4gIGxldCBpc0RlYnVnT24gPSBmYWxzZTtcbiAgKGVudi5ERUJVRyB8fCAnJykudG9Mb3dlckNhc2UoKS5zcGxpdCgnLCcpLmZvckVhY2goZSA9PiB7XG4gICAgaWYgKCEhZSAmJiAoZSA9PT0gJyonIHx8IHR5cGUgPT09IGUgfHwgZS5lbmRzV2l0aCgnKicpICYmIHR5cGUuc3RhcnRzV2l0aChlLnNsaWNlKDAsIC0xKSkpKSB7XG4gICAgICBpc0RlYnVnT24gPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghIWUgJiYgZS5zdGFydHNXaXRoKCctJykgJiYgKHR5cGUgPT09IGUuc2xpY2UoMSkgfHwgZS5lbmRzV2l0aCgnKicpICYmIHR5cGUuc3RhcnRzV2l0aChlLnNsaWNlKDEsIC0xKSkpKSB7XG4gICAgICBpc0RlYnVnT24gPSBmYWxzZTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gW2lzRGVidWdPbiwgaXNOYU4obWF4U2l6ZSkgPyAtMSA6IG1heFNpemVdO1xufVxuLyoqXG4gKiBAbmFtZSBMb2dnZXJcbiAqIEBzdW1tYXJ5IENyZWF0ZXMgYSBjb25zaXN0ZW50IGxvZyBpbnRlcmZhY2UgZm9yIG1lc3NhZ2VzXG4gKiBAZGVzY3JpcHRpb25cbiAqIFJldHVybnMgYSBgTG9nZ2VyYCB0aGF0IGhhcyBgLmxvZ2AsIGAuZXJyb3JgLCBgLndhcm5gIGFuZCBgLmRlYnVnYCAoY29udHJvbGxlZCB3aXRoIGVudmlyb25tZW50IGBERUJVRz10eXBlQSx0eXBlQmApIG1ldGhvZHMuIExvZ2dpbmcgaXMgZG9uZSB3aXRoIGEgY29uc2lzdGVudCBwcmVmaXggKHR5cGUgb2YgbG9nZ2VyLCBkYXRlKSBmb2xsb3dlZCBieSB0aGUgYWN0dWFsIG1lc3NhZ2UgdXNpbmcgdGhlIHVuZGVybHlpbmcgY29uc29sZS5cbiAqIEBleGFtcGxlXG4gKiA8QlI+XG4gKlxuICogYGBgamF2YXNjcmlwdFxuICogaW1wb3J0IHsgbG9nZ2VyIH0gZnJvbSAnQHBvbGthZG90JztcbiAqXG4gKiBjb25zdCBsID0gbG9nZ2VyKCd0ZXN0Jyk7XG4gKiBgYGBcbiAqL1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBsb2dnZXIoX3R5cGUpIHtcbiAgY29uc3QgdHlwZSA9IGAke190eXBlLnRvVXBwZXJDYXNlKCl9OmAucGFkU3RhcnQoMTYpO1xuICBjb25zdCBbaXNEZWJ1ZywgbWF4U2l6ZV0gPSBwYXJzZUVudihfdHlwZS50b0xvd2VyQ2FzZSgpKTtcbiAgcmV0dXJuIHtcbiAgICBkZWJ1ZzogaXNEZWJ1ZyA/ICguLi52YWx1ZXMpID0+IGFwcGx5KCdkZWJ1ZycsIHR5cGUsIHZhbHVlcywgbWF4U2l6ZSkgOiBub29wLFxuICAgIGVycm9yOiAoLi4udmFsdWVzKSA9PiBhcHBseSgnZXJyb3InLCB0eXBlLCB2YWx1ZXMpLFxuICAgIGxvZzogKC4uLnZhbHVlcykgPT4gYXBwbHkoJ2xvZycsIHR5cGUsIHZhbHVlcyksXG4gICAgbm9vcCxcbiAgICB3YXJuOiAoLi4udmFsdWVzKSA9PiBhcHBseSgnd2FybicsIHR5cGUsIHZhbHVlcylcbiAgfTtcbn0iLCIvLyBDb3B5cmlnaHQgMjAxNy0yMDIxIEBwb2xrYWRvdC91dGlsIGF1dGhvcnMgJiBjb250cmlidXRvcnNcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBBcGFjaGUtMi4wXG5pbXBvcnQgeyBpc0JpZ0ludCB9IGZyb20gXCIuL2lzL2JpZ0ludC5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHN0cmluZ2lmeShhcmdzLCBzcGFjZSkge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJncywgKF8sIHZhbHVlKSA9PiBpc0JpZ0ludCh2YWx1ZSkgPyB2YWx1ZS50b1N0cmluZygpIDogdmFsdWUsIHNwYWNlKTtcbn0iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMSAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcblxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG4vLyBPdmVycmlkZXMgYGNvbXBhdC1ub2RlanMuanNgIHdoZW4gaW4gYSBicm93c2VyLlxuXG5leHBvcnQgY29uc3QgbmV0ID0gbnVsbDtcbmV4cG9ydCBjb25zdCBXb3JrZXIgPSB0eXBlb2Ygd2luZG93ICE9ICd1bmRlZmluZWQnID8gd2luZG93LldvcmtlciA6IG51bGw7XG5leHBvcnQgY29uc3Qgd29ya2VyT25NZXNzYWdlID0gKHdvcmtlciwgY2FsbGJhY2spID0+IHsgd29ya2VyLm9ubWVzc2FnZSA9IChldmVudCkgPT4gY2FsbGJhY2soZXZlbnQuZGF0YSkgfTtcbmV4cG9ydCBjb25zdCB3b3JrZXJPbkVycm9yID0gKHdvcmtlciwgY2FsbGJhY2spID0+IHsgd29ya2VyLm9uZXJyb3IgPSBjYWxsYmFjazsgfTsgIC8vIFRPRE86IHVuY2xlYXIgaWYgdGhlIHBhcmFtZXRlciBvZiB0aGUgY2FsbGJhY2sgaXMgc2FtZSBhcyB3aXRoIE5vZGVKU1xuZXhwb3J0IGNvbnN0IHBvc3RNZXNzYWdlID0gKG1zZykgPT4gc2VsZi5wb3N0TWVzc2FnZShtc2cpO1xuZXhwb3J0IGNvbnN0IHNldE9uTWVzc2FnZSA9IChjYWxsYmFjaykgPT4geyBzZWxmLm9ubWVzc2FnZSA9IChldmVudCkgPT4gY2FsbGJhY2soZXZlbnQuZGF0YSkgfTtcbiIsIi8vIFNtb2xkb3Rcbi8vIENvcHlyaWdodCAoQykgMjAxOS0yMDIxICBQYXJpdHkgVGVjaG5vbG9naWVzIChVSykgTHRkLlxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IEdQTC0zLjAtb3ItbGF0ZXIgV0lUSCBDbGFzc3BhdGgtZXhjZXB0aW9uLTIuMFxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTogeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuLy8gaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbi8vIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIGVpdGhlciB2ZXJzaW9uIDMgb2YgdGhlIExpY2Vuc2UsIG9yXG4vLyAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4vLyBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbi8vIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4vLyBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4vLyBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4vLyBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuLy8gYWxvbmcgd2l0aCB0aGlzIHByb2dyYW0uICBJZiBub3QsIHNlZSA8aHR0cDovL3d3dy5nbnUub3JnL2xpY2Vuc2VzLz4uXG5cbi8vIENyZWF0ZXMgYSBuZXcgaGVhbHRoIGNoZWNrZXIuXG4vL1xuLy8gVGhlIHJvbGUgb2YgdGhlIGhlYWx0aCBjaGVja2VyIGlzIHRvIHJlcG9ydCB0byB0aGUgdXNlciB0aGUgaGVhbHRoIG9mIGEgc21vbGRvdCBjaGFpbi5cbi8vXG4vLyBJbiBvcmRlciB0byB1c2UgaXQsIHN0YXJ0IGJ5IGNyZWF0aW5nIGEgaGVhbHRoIGNoZWNrZXIsIGFuZCBjYWxsIGBzZXRTZW5kSnNvblJwY2AgdG8gc2V0IHRoZVxuLy8gd2F5IHRvIHNlbmQgYSBKU09OLVJQQyByZXF1ZXN0IHRvIGEgY2hhaW4uIFRoZSBoZWFsdGggY2hlY2tlciBpcyBkaXNhYmxlZCBieSBkZWZhdWx0LiBVc2Vcbi8vIGBzdGFydCgpYCBpbiBvcmRlciB0byBzdGFydCB0aGUgaGVhbHRoIGNoZWNrcy4gVGhlIGBzdGFydCgpYCBmdW5jdGlvbiBtdXN0IGJlIHBhc3NlZCBhIGNhbGxiYWNrIGNhbGxlZFxuLy8gd2hlbiBhbiB1cGRhdGUgdG8gdGhlIGhlYWx0aCBvZiB0aGUgbm9kZSBpcyBhdmFpbGFibGUuXG4vL1xuLy8gSW4gb3JkZXIgdG8gc2VuZCBhIEpTT04tUlBDIHJlcXVlc3QgdG8gdGhlIGNoYWluLCB5b3UgKiptdXN0KiogdXNlIHRoZSBgc2VuZEpzb25ScGNgIGZ1bmN0aW9uXG4vLyBvZiB0aGUgaGVhbHRoIGNoZWNrZXIuIFRoZSBoZWFsdGggY2hlY2tlciByZXdyaXRlcyB0aGUgYGlkYCBvZiB0aGUgcmVxdWVzdHMgaXQgcmVjZWl2ZXMuXG4vL1xuLy8gV2hlbiB0aGUgY2hhaW4gc2VuZCBhIEpTT04tUlBDIHJlc3BvbnNlLCBpdCBtdXN0IGJlIHBhc3NlZCB0byBgcmVzcG9uc2VQYXNzVGhyb3VnaCgpYC4gVGhpc1xuLy8gZnVuY3Rpb24gaW50ZXJjZXB0cyB0aGUgcmVzcG9uc2VzIGRlc3RpbmVkIHRvIHRoZSByZXF1ZXN0cyB0aGF0IGhhdmUgYmVlbiBlbWl0dGVkIGJ5IHRoZSBoZWFsdGhcbi8vIGNoZWNrZXIgYW5kIHJldHVybnMgYG51bGxgLiBJZiB0aGUgcmVzcG9uc2UgZG9lc24ndCBjb25jZXJuIHRoZSBoZWFsdGggY2hlY2tlciwgdGhlIHJlc3BvbnNlIGlzXG4vLyBzaW1wbHkgcmV0dXJuZWQgYnkgdGhlIGZ1bmN0aW9uLlxuLy9cbi8vICMgSG93IGl0IHdvcmtzXG4vL1xuLy8gVGhlIGhlYWx0aCBjaGVja2VyIHBlcmlvZGljYWxseSBjYWxscyB0aGUgYHN5c3RlbV9oZWFsdGhgIEpTT04tUlBDIGNhbGwgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lXG4vLyB0aGUgaGVhbHRoIG9mIHRoZSBjaGFpbi5cbi8vXG4vLyBJbiBhZGRpdGlvbiB0byB0aGlzLCBhcyBsb25nIGFzIHRoZSBoZWFsdGggY2hlY2sgcmVwb3J0cyB0aGF0IGBpc1N5bmNpbmdgIGlzIGB0cnVlYCwgdGhlXG4vLyBoZWFsdGggY2hlY2tlciBhbHNvIG1haW50YWlucyBhIHN1YnNjcmlwdGlvbiB0byBuZXcgYmVzdCBibG9ja3MgdXNpbmcgYGNoYWluX3N1YnNjcmliZU5ld0hlYWRzYC5cbi8vIFdoZW5ldmVyIGEgbmV3IGJsb2NrIGlzIG5vdGlmaWVkLCBhIGhlYWx0aCBjaGVjayBpcyBwZXJmb3JtZWQgaW1tZWRpYXRlbHkgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lXG4vLyB3aGV0aGVyIGBpc1N5bmNpbmdgIGhhcyBjaGFuZ2VkIHRvIGBmYWxzZWAuXG4vL1xuLy8gVGhhbmtzIHRvIHRoaXMgc3Vic2NyaXB0aW9uLCB0aGUgbGF0ZW5jeSBvZiB0aGUgcmVwb3J0IG9mIHRoZSBzd2l0Y2ggZnJvbSBgaXNTeW5jaW5nOiB0cnVlYCB0b1xuLy8gYGlzU3luY2luZzogZmFsc2VgIGlzIHZlcnkgbG93LlxuLy9cbmV4cG9ydCBmdW5jdGlvbiBoZWFsdGhDaGVja2VyKCkge1xuICAgIC8vIGBudWxsYCBpZiBoZWFsdGggY2hlY2tlciBpcyBub3Qgc3RhcnRlZC5cbiAgICBsZXQgY2hlY2tlciA9IG51bGw7XG4gICAgbGV0IHNlbmRKc29uUnBjID0gbnVsbDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHNldFNlbmRKc29uUnBjOiAoY2IpID0+IHtcbiAgICAgICAgICAgIHNlbmRKc29uUnBjID0gY2I7XG4gICAgICAgIH0sXG5cbiAgICAgICAgc3RhcnQ6IChoZWFsdGhDYWxsYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIgIT09IG51bGwpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc3RhcnQgdGhlIGhlYWx0aCBjaGVja2VyIG11bHRpcGxlIHRpbWVzIGluIHBhcmFsbGVsXCIpO1xuICAgICAgICAgICAgaWYgKCFzZW5kSnNvblJwYylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJzZXRTZW5kSnNvblJwYyBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgc3RhcnRpbmcgdGhlIGhlYWx0aCBjaGVja3NcIik7XG5cbiAgICAgICAgICAgIGNoZWNrZXIgPSB7XG4gICAgICAgICAgICAgICAgaGVhbHRoQ2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgY3VycmVudEhlYWx0aENoZWNrSWQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudEhlYWx0aFRpbWVvdXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgY3VycmVudFN1YnVuc3ViUmVxdWVzdElkOiBudWxsLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRTdWJzY3JpcHRpb25JZDogbnVsbCxcbiAgICAgICAgICAgICAgICBpc1N5bmNpbmc6IGZhbHNlLFxuICAgICAgICAgICAgICAgIG5leHRSZXF1ZXN0SWQ6IDAsXG5cbiAgICAgICAgICAgICAgICBzZW5kSnNvblJwYzogZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSB0aGUgYGlkYCBpbiB0aGUgcmVxdWVzdCB0byBwcmVmaXggdGhlIHJlcXVlc3QgSUQgd2l0aCBgZXh0ZXJuOmAuXG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRSZXF1ZXN0O1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVxdWVzdCA9IEpTT04ucGFyc2UocmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZXF1ZXN0LmlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJZCA9ICdleHRlcm46JyArIEpTT04uc3RyaW5naWZ5KHBhcnNlZFJlcXVlc3QuaWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVxdWVzdC5pZCA9IG5ld0lkO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgc2VuZEpzb25ScGMoSlNPTi5zdHJpbmdpZnkocGFyc2VkUmVxdWVzdCkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICByZXNwb25zZVBhc3NUaHJvdWdoOiBmdW5jdGlvbiAoanNvblJwY1Jlc3BvbnNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBwYXJzZWRSZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZFJlc3BvbnNlID0gSlNPTi5wYXJzZShqc29uUnBjUmVzcG9uc2UpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBqc29uUnBjUmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciByZXNwb25zZSBpcyBhIHJlc3BvbnNlIHRvIGBzeXN0ZW1faGVhbHRoYC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFJlc3BvbnNlLmlkICYmIHRoaXMuY3VycmVudEhlYWx0aENoZWNrSWQgPT0gcGFyc2VkUmVzcG9uc2UuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEhlYWx0aENoZWNrSWQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHF1ZXJ5IHdhcyBzdWNjZXNzZnVsLiBJdCBpcyBwb3NzaWJsZSBmb3IgcXVlcmllcyB0byBmYWlsIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaW91cyByZWFzb25zLCBzdWNoIGFzIHRoZSBjbGllbnQgYmVpbmcgb3ZlcmxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5oZWFsdGhDYWxsYmFjayhwYXJzZWRSZXNwb25zZS5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pc1N5bmNpbmcgPSBwYXJzZWRSZXNwb25zZS5yZXN1bHQuaXNTeW5jaW5nO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciByZXNwb25zZSBpcyBhIHJlc3BvbnNlIHRvIHRoZSBzdWJzY3JpcHRpb24gb3IgdW5zdWJzY3JpcHRpb24uXG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5pZCAmJiB0aGlzLmN1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCA9PSBwYXJzZWRSZXNwb25zZS5pZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgPSBudWxsO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHF1ZXJ5IHdhcyBzdWNjZXNzZnVsLiBJdCBpcyBwb3NzaWJsZSBmb3IgcXVlcmllcyB0byBmYWlsIGZvclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFyaW91cyByZWFzb25zLCBzdWNoIGFzIHRoZSBjbGllbnQgYmVpbmcgb3ZlcmxvYWRlZC5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghcGFyc2VkUmVzcG9uc2UucmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbklkID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZCA9IHBhcnNlZFJlc3BvbnNlLnJlc3VsdDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgd2hldGhlciByZXNwb25zZSBpcyBhIG5vdGlmaWNhdGlvbiB0byBhIHN1YnNjcmlwdGlvbi5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcnNlZFJlc3BvbnNlLnBhcmFtcyAmJiB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UucGFyYW1zLnN1YnNjcmlwdGlvbiA9PSB0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gTm90ZSB0aGF0IGFmdGVyIGEgc3VjY2Vzc2Z1bCBzdWJzY3JpcHRpb24sIGEgbm90aWZpY2F0aW9uIGNvbnRhaW5pbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoZSBjdXJyZW50IGJlc3QgYmxvY2sgaXMgYWx3YXlzIHJldHVybmVkLiBDb25zaWRlcmluZyB0aGF0IGFcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN1YnNjcmlwdGlvbiBpcyBwZXJmb3JtZWQgaW4gcmVzcG9uc2UgdG8gYSBoZWFsdGggY2hlY2ssIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGBzdGFydEhlYWx0aENoZWNrKClgIGhlcmUgd2lsbCBsZWFkIHRvIGEgc2Vjb25kIGhlYWx0aCBjaGVjay5cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEl0IG1pZ2h0IHNlZW0gcmVkdW5kYW50IHRvIHBlcmZvcm0gdHdvIGhlYWx0aCBjaGVja3MgaW4gYSBxdWlja1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc3VjY2Vzc2lvbiwgYnV0IGRvaW5nIHNvIGRvZXNuJ3QgbGVhZCB0byBhbnkgcHJvYmxlbSwgYW5kIGl0IGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhY3R1YWxseSBwb3NzaWJsZSBmb3IgdGhlIGhlYWx0aCB0byBoYXZlIGNoYW5nZWQgaW4gYmV0d2VlbiBhcyB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGN1cnJlbnQgYmVzdCBibG9jayBtaWdodCBoYXZlIGJlZW4gdXBkYXRlZCBkdXJpbmcgdGhlIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWVzdC5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRIZWFsdGhDaGVjaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy51cGRhdGUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gUmVzcG9uc2UgZG9lc24ndCBjb25jZXJuIHVzLlxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyc2VkUmVzcG9uc2UuaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5lZWQgdG8gcmVtb3ZlIHRoZSBgZXh0ZXJuOmAgcHJlZml4LlxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwYXJzZWRSZXNwb25zZS5pZC5zdGFydHNXaXRoKCdleHRlcm46JykpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTdGF0ZSBpbmNvbnNpc3RlbmN5IGluIGhlYWx0aCBjaGVja2VyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBuZXdJZCA9IEpTT04ucGFyc2UocGFyc2VkUmVzcG9uc2UuaWQuc2xpY2UoJ2V4dGVybjonLmxlbmd0aCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UuaWQgPSBuZXdJZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShwYXJzZWRSZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY3VycmVudEhlYWx0aFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudEhlYWx0aFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SGVhbHRoQ2hlY2soKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDAwKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzU3luY2luZyAmJiAhdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uSWQgJiYgIXRoaXMuY3VycmVudFN1YnVuc3ViUmVxdWVzdElkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydFN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNTeW5jaW5nICYmIHRoaXMuY3VycmVudFN1YnNjcmlwdGlvbklkICYmICF0aGlzLmN1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW5kU3Vic2NyaXB0aW9uKCk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIHN0YXJ0SGVhbHRoQ2hlY2s6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudEhlYWx0aENoZWNrSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yIGluIGhlYWx0aCBjaGVja2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmN1cnJlbnRIZWFsdGhUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jdXJyZW50SGVhbHRoVGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRIZWFsdGhDaGVja0lkID0gXCJoZWFsdGgtY2hlY2tlcjpcIiArIHRoaXMubmV4dFJlcXVlc3RJZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWVzdElkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRKc29uUnBjKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5jdXJyZW50SGVhbHRoQ2hlY2tJZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ3N5c3RlbV9oZWFsdGgnLFxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgICAgICBzdGFydFN1YnNjcmlwdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgfHwgdGhpcy5jdXJyZW50U3Vic2NyaXB0aW9uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGVycm9yIGluIGhlYWx0aCBjaGVja2VyJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY3VycmVudFN1YnVuc3ViUmVxdWVzdElkID0gXCJoZWFsdGgtY2hlY2tlcjpcIiArIHRoaXMubmV4dFJlcXVlc3RJZDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0UmVxdWVzdElkICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIHNlbmRKc29uUnBjKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdGhpcy5jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXRob2Q6ICdjaGFpbl9zdWJzY3JpYmVOZXdIZWFkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgICAgIGVuZFN1YnNjcmlwdGlvbjogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50U3VidW5zdWJSZXF1ZXN0SWQgfHwgIXRoaXMuY3VycmVudFN1YnNjcmlwdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBlcnJvciBpbiBoZWFsdGggY2hlY2tlcicpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnRTdWJ1bnN1YlJlcXVlc3RJZCA9IFwiaGVhbHRoLWNoZWNrZXI6XCIgKyB0aGlzLm5leHRSZXF1ZXN0SWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmV4dFJlcXVlc3RJZCArPSAxO1xuICAgICAgICAgICAgICAgICAgICBzZW5kSnNvblJwYyhKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuY3VycmVudFN1YnVuc3ViUmVxdWVzdElkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnY2hhaW5fdW5zdWJzY3JpYmVOZXdIZWFkcycsXG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IFt0aGlzLmN1cnJlbnRTdWJzY3JpcHRpb25JZF0sXG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICB9LFxuXG4gICAgICAgICAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5jdXJyZW50SGVhbHRoVGltZW91dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY3VycmVudEhlYWx0aFRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jdXJyZW50SGVhbHRoVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBjaGVja2VyLnN0YXJ0SGVhbHRoQ2hlY2soKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogKCkgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrZXIgPT09IG51bGwpXG4gICAgICAgICAgICAgICAgcmV0dXJuOyAvLyBBbHJlYWR5IHN0b3BwZWQuXG4gICAgICAgICAgICBjaGVja2VyLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGNoZWNrZXIgPSBudWxsO1xuICAgICAgICB9LFxuICAgICAgICBzZW5kSnNvblJwYzogKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgIGlmICghc2VuZEpzb25ScGMpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwic2V0U2VuZEpzb25ScGMgbXVzdCBiZSBjYWxsZWQgYmVmb3JlIHNlbmRpbmcgcmVxdWVzdHNcIik7XG4gICAgICAgICAgICBpZiAoY2hlY2tlciA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICBzZW5kSnNvblJwYyhyZXF1ZXN0KTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBjaGVja2VyLnNlbmRKc29uUnBjKHJlcXVlc3QpO1xuICAgICAgICB9LFxuICAgICAgICByZXNwb25zZVBhc3NUaHJvdWdoOiAoanNvblJwY1Jlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2tlciA9PT0gbnVsbClcbiAgICAgICAgICAgICAgICByZXR1cm4ganNvblJwY1Jlc3BvbnNlO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrZXIucmVzcG9uc2VQYXNzVGhyb3VnaChqc29uUnBjUmVzcG9uc2UpO1xuICAgICAgICB9LFxuICAgIH07XG59XG4iLCIvLyBTbW9sZG90XG4vLyBDb3B5cmlnaHQgKEMpIDIwMTktMjAyMSAgUGFyaXR5IFRlY2hub2xvZ2llcyAoVUspIEx0ZC5cbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBHUEwtMy4wLW9yLWxhdGVyIFdJVEggQ2xhc3NwYXRoLWV4Y2VwdGlvbi0yLjBcblxuLy8gVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU6IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbi8vIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4vLyB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCBlaXRoZXIgdmVyc2lvbiAzIG9mIHRoZSBMaWNlbnNlLCBvclxuLy8gKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuLy8gVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4vLyBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuLy8gTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuLy8gR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuLy8gWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEdlbmVyYWwgUHVibGljIExpY2Vuc2Vcbi8vIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiAgSWYgbm90LCBzZWUgPGh0dHA6Ly93d3cuZ251Lm9yZy9saWNlbnNlcy8+LlxuXG5pbXBvcnQgeyBXb3JrZXIsIHdvcmtlck9uRXJyb3IsIHdvcmtlck9uTWVzc2FnZSB9IGZyb20gJy4vY29tcGF0LW5vZGVqcy5qcyc7XG5leHBvcnQgKiBmcm9tICcuL2hlYWx0aC5qcyc7XG5cbmV4cG9ydCBjbGFzcyBBbHJlYWR5RGVzdHJveWVkRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG5cbmV4cG9ydCBjbGFzcyBBZGRDaGFpbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEpzb25ScGNEaXNhYmxlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuXG5leHBvcnQgY2xhc3MgQ3Jhc2hFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgIHN1cGVyKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdGFydChjb25maWcpIHtcbiAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xuXG4gIGNvbnN0IGxvZ0NhbGxiYWNrID0gY29uZmlnLmxvZ0NhbGxiYWNrIHx8ICgobGV2ZWwsIHRhcmdldCwgbWVzc2FnZSkgPT4ge1xuICAgIGlmIChsZXZlbCA8PSAxKSB7XG4gICAgICBjb25zb2xlLmVycm9yKFwiW1wiICsgdGFyZ2V0ICsgXCJdXCIsIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWwgPT0gMikge1xuICAgICAgY29uc29sZS53YXJuKFwiW1wiICsgdGFyZ2V0ICsgXCJdXCIsIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWwgPT0gMykge1xuICAgICAgY29uc29sZS5pbmZvKFwiW1wiICsgdGFyZ2V0ICsgXCJdXCIsIG1lc3NhZ2UpO1xuICAgIH0gZWxzZSBpZiAobGV2ZWwgPT0gNCkge1xuICAgICAgY29uc29sZS5kZWJ1ZyhcIltcIiArIHRhcmdldCArIFwiXVwiLCBtZXNzYWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS50cmFjZShcIltcIiArIHRhcmdldCArIFwiXVwiLCBtZXNzYWdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIFRoZSBhY3R1YWwgZXhlY3V0aW9uIG9mIFNtb2xkb3QgaXMgcGVyZm9ybWVkIGluIGEgd29ya2VyIHRocmVhZC5cbiAgLy9cbiAgLy8gVGhlIGxpbmUgb2YgY29kZSBiZWxvdyAoYG5ldyBXb3JrZXIoLi4uKWApIGlzIGRlc2lnbmVkIHRvIGhvcGVmdWxseSB3b3JrIGFjcm9zcyBhbGxcbiAgLy8gcGxhdGZvcm1zIGFuZCBidW5kbGVycy4gU2VlIHRoZSBSRUFETUUubWQgZm9yIG1vcmUgY29udGV4dC5cbiAgY29uc3Qgd29ya2VyID0gbmV3IFdvcmtlcihuZXcgVVJMKCcuL3dvcmtlci5qcycsIGltcG9ydC5tZXRhLnVybCkpO1xuICBsZXQgd29ya2VyRXJyb3IgPSBudWxsO1xuXG4gIC8vIFdoZW5ldmVyIGFuIGBhZGRDaGFpbmAgb3IgYHJlbW92ZUNoYWluYCBtZXNzYWdlIGlzIHNlbnQgdG8gdGhlIHdvcmtlciwgYSBjb3JyZXNwb25kaW5nIGVudHJ5XG4gIC8vIGlzIHB1c2hlZCB0byB0aGlzIGFycmF5LiBUaGUgd29ya2VyIG5lZWRzIHRvIHNlbmQgYmFjayBhIGNvbmZpcm1hdGlvbiwgd2hpY2ggcG9wcyB0aGUgZmlyc3RcbiAgLy8gZWxlbWVudCBvZiB0aGlzIGFycmF5LiBJbiB0aGUgY2FzZSBvZiBgYWRkQ2hhaW5gLCBhZGRpdGlvbmFsIGZpZWxkcyBhcmUgc3RvcmVkIGluIHRoaXMgYXJyYXlcbiAgLy8gdG8gZmluaXNoIHRoZSBpbml0aWFsaXphdGlvbiBvZiB0aGUgY2hhaW4uXG4gIGxldCBwZW5kaW5nQ29uZmlybWF0aW9ucyA9IFtdO1xuXG4gIC8vIEZvciBlYWNoIGNoYWluIHRoYXQgaXMgY3VycmVudGx5IHJ1bm5pbmcsIGNvbnRhaW5zIHRoZSBjYWxsYmFjayB0byB1c2UgdG8gc2VuZCBiYWNrIEpTT04tUlBDXG4gIC8vIHJlc3BvbnNlcyBjb3JyZXNwb25kaW5nIHRvIHRoaXMgY2hhaW4uXG4gIC8vIEVudHJpZXMgYXJlIGluc3RhbnRseSByZW1vdmVkIHdoZW4gdGhlIHVzZXIgZGVzaXJlcyB0byByZW1vdmUgYSBjaGFpbiBldmVuIGJlZm9yZSB0aGUgd29ya2VyXG4gIC8vIGhhcyBjb25maXJtZWQgdGhlIHJlbW92YWwuIERvaW5nIHNvIGF2b2lkcyBhIHJhY2UgY29uZGl0aW9uIHdoZXJlIHRoZSB3b3JrZXIgc2VuZHMgYmFjayBhXG4gIC8vIEpTT04tUlBDIHJlc3BvbnNlIGV2ZW4gdGhvdWdoIHdlJ3ZlIGFscmVhZHkgc2VudCBhIGByZW1vdmVDaGFpbmAgbWVzc2FnZSB0byBpdC5cbiAgbGV0IGNoYWluc0pzb25ScGNDYWxsYmFja3MgPSBuZXcgTWFwKCk7XG5cbiAgLy8gVGhlIHdvcmtlciBwZXJpb2RpY2FsbHkgc2VuZHMgYSBtZXNzYWdlIG9mIGtpbmQgJ2xpdmVuZXNzUGluZycgaW4gb3JkZXIgdG8gbm90aWZ5IHRoYXQgaXQgaXNcbiAgLy8gc3RpbGwgYWxpdmUuXG4gIC8vIElmIHRoaXMgbGl2ZW5lc3MgcGluZyBpc24ndCByZWNlaXZlZCBmb3IgYSBsb25nIHRpbWUsIGFuIGVycm9yIGlzIHJlcG9ydGVkIGluIHRoZSBsb2dzLlxuICAvLyBUaGUgZmlyc3QgY2hlY2sgaXMgZGVsYXllZCBpbiBvcmRlciB0byBhY2NvdW50IGZvciB0aGUgZmFjdCB0aGF0IHRoZSB3b3JrZXIgaGFzIHRvIHBlcmZvcm1cbiAgLy8gYW4gZXhwZW5zaXZlIGluaXRpYWxpemF0aW9uIHN0ZXAgd2hlbiBpbml0aWFsaXppbmcgdGhlIFdhc20gVk0uXG4gIGxldCBsaXZlbmVzc1RpbWVvdXQgPSBudWxsO1xuICBjb25zdCByZXNldExpdmVuZXNzVGltZW91dCA9ICgpID0+IHtcbiAgICBpZiAobGl2ZW5lc3NUaW1lb3V0ICE9PSBudWxsKVxuICAgICAgY2xlYXJUaW1lb3V0KGxpdmVuZXNzVGltZW91dCk7XG4gICAgbGl2ZW5lc3NUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBsaXZlbmVzc1RpbWVvdXQgPSBudWxsO1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICBcIlNtb2xkb3QgYXBwZWFycyB1bnJlc3BvbnNpdmUuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IFwiICtcbiAgICAgICAgXCJodHRwczovL2dpdGh1Yi5jb20vcGFyaXR5dGVjaC9zbW9sZG90L2lzc3Vlcy4gSWYgeW91IGhhdmUgYSBkZWJ1Z2dlciBhdmFpbGFibGUsIFwiICtcbiAgICAgICAgXCJwbGVhc2UgcGF1c2UgZXhlY3V0aW9uLCBnZW5lcmF0ZSBhIHN0YWNrIHRyYWNlIG9mIHRoZSB0aHJlYWQgdGhhdCBpc24ndCB0aGUgbWFpbiBcIiArXG4gICAgICAgIFwiZXhlY3V0aW9uIHRocmVhZCwgYW5kIHBhc3RlIGl0IGluIHRoZSBpc3N1ZS4gUGxlYXNlIGFsc28gaW5jbHVkZSBhbnkgb3RoZXIgbG9nIGZvdW5kIFwiICtcbiAgICAgICAgXCJpbiB0aGUgY29uc29sZSBvciBlbHNld2hlcmUuXCJcbiAgICAgICk7XG4gICAgfSwgMTAwMDApO1xuICB9O1xuICBzZXRUaW1lb3V0KCgpID0+IHJlc2V0TGl2ZW5lc3NUaW1lb3V0KCksIDE1MDAwKTtcblxuICAvLyBUaGUgd29ya2VyIGNhbiBzZW5kIHVzIG1lc3NhZ2VzIHdob3NlIHR5cGUgaXMgaWRlbnRpZmllZCB0aHJvdWdoIGEgYGtpbmRgIGZpZWxkLlxuICB3b3JrZXJPbk1lc3NhZ2Uod29ya2VyLCAobWVzc2FnZSkgPT4ge1xuICAgIGlmIChtZXNzYWdlLmtpbmQgPT0gJ2pzb25ycGMnKSB7XG4gICAgICBjb25zdCBjYiA9IGNoYWluc0pzb25ScGNDYWxsYmFja3MuZ2V0KG1lc3NhZ2UuY2hhaW5JZCk7XG4gICAgICBpZiAoY2IpIGNiKG1lc3NhZ2UuZGF0YSk7XG5cbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uua2luZCA9PSAnY2hhaW5BZGRlZE9rJykge1xuICAgICAgY29uc3QgZXhwZWN0ZWQgPSBwZW5kaW5nQ29uZmlybWF0aW9ucy5zaGlmdCgpO1xuICAgICAgbGV0IGNoYWluSWQgPSBtZXNzYWdlLmNoYWluSWQ7IC8vIExhdGVyIHNldCB0byBudWxsIHdoZW4gdGhlIGNoYWluIGlzIHJlbW92ZWQuXG5cbiAgICAgIGlmIChjaGFpbnNKc29uUnBjQ2FsbGJhY2tzLmhhcyhjaGFpbklkKSkgLy8gU2FuaXR5IGNoZWNrLlxuICAgICAgICB0aHJvdyAnVW5leHBlY3RlZCByZXVzZSBvZiBhIGNoYWluIElEJztcbiAgICAgIGNoYWluc0pzb25ScGNDYWxsYmFja3Muc2V0KGNoYWluSWQsIGV4cGVjdGVkLmpzb25ScGNDYWxsYmFjayk7XG5cbiAgICAgIC8vIGBleHBlY3RlZGAgd2FzIHB1c2hlZCBieSB0aGUgYGFkZENoYWluYCBtZXRob2QuXG4gICAgICAvLyBSZXNvbHZlIHRoZSBwcm9taXNlIHRoYXQgYGFkZENoYWluYCByZXR1cm5lZCB0byB0aGUgdXNlci5cbiAgICAgIGV4cGVjdGVkLnJlc29sdmUoe1xuICAgICAgICBzZW5kSnNvblJwYzogKHJlcXVlc3QpID0+IHtcbiAgICAgICAgICBpZiAod29ya2VyRXJyb3IpXG4gICAgICAgICAgICB0aHJvdyB3b3JrZXJFcnJvcjtcbiAgICAgICAgICBpZiAoY2hhaW5JZCA9PT0gbnVsbClcbiAgICAgICAgICAgIHRocm93IG5ldyBBbHJlYWR5RGVzdHJveWVkRXJyb3IoKTtcbiAgICAgICAgICBpZiAoIWNoYWluc0pzb25ScGNDYWxsYmFja3MuaGFzKGNoYWluSWQpKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEpzb25ScGNEaXNhYmxlZEVycm9yKCk7XG4gICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHsgdHk6ICdyZXF1ZXN0JywgcmVxdWVzdCwgY2hhaW5JZCB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlOiAoKSA9PiB7XG4gICAgICAgICAgaWYgKHdvcmtlckVycm9yKVxuICAgICAgICAgICAgdGhyb3cgd29ya2VyRXJyb3I7XG4gICAgICAgICAgaWYgKGNoYWluSWQgPT09IG51bGwpXG4gICAgICAgICAgICB0aHJvdyBuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCk7XG4gICAgICAgICAgcGVuZGluZ0NvbmZpcm1hdGlvbnMucHVzaCh7IHR5OiAnY2hhaW5SZW1vdmVkJywgY2hhaW5JZCB9KTtcbiAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2UoeyB0eTogJ3JlbW92ZUNoYWluJywgY2hhaW5JZCB9KTtcbiAgICAgICAgICAvLyBCZWNhdXNlIHRoZSBgcmVtb3ZlQ2hhaW5gIG1lc3NhZ2UgaXMgYXN5bmNocm9ub3VzLCBpdCBpcyBwb3NzaWJsZSBmb3IgYSBKU09OLVJQQ1xuICAgICAgICAgIC8vIHJlc3BvbnNlIGNvbmNlcm5pbmcgdGhhdCBgY2hhaW5JZGAgdG8gYXJyaXZlIGFmdGVyIHRoZSBgcmVtb3ZlYCBmdW5jdGlvbiBoYXNcbiAgICAgICAgICAvLyByZXR1cm5lZC4gV2Ugc29sdmUgdGhhdCBieSByZW1vdmluZyB0aGUgY2FsbGJhY2sgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgY2hhaW5zSnNvblJwY0NhbGxiYWNrcy5kZWxldGUoY2hhaW5JZCk7XG4gICAgICAgICAgY2hhaW5JZCA9IG51bGw7XG4gICAgICAgIH0sXG4gICAgICAgIC8vIEhhY2t5IGludGVybmFsIG1ldGhvZCB0aGF0IGxhdGVyIGxldHMgdXMgYWNjZXNzIHRoZSBgY2hhaW5JZGAgb2YgdGhpcyBjaGFpbiBmb3JcbiAgICAgICAgLy8gaW1wbGVtZW50YXRpb24gcmVhc29ucy5cbiAgICAgICAgX19pbnRlcm5hbF9zbW9sZG90X2lkOiAoKSA9PiBjaGFpbklkLFxuICAgICAgfSk7XG5cbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2Uua2luZCA9PSAnY2hhaW5BZGRlZEVycicpIHtcbiAgICAgIGNvbnN0IGV4cGVjdGVkID0gcGVuZGluZ0NvbmZpcm1hdGlvbnMuc2hpZnQoKTtcbiAgICAgIC8vIGBleHBlY3RlZGAgd2FzIHB1c2hlZCBieSB0aGUgYGFkZENoYWluYCBtZXRob2QuXG4gICAgICAvLyBSZWplY3QgdGhlIHByb21pc2UgdGhhdCBgYWRkQ2hhaW5gIHJldHVybmVkIHRvIHRoZSB1c2VyLlxuICAgICAgZXhwZWN0ZWQucmVqZWN0KG5ldyBBZGRDaGFpbkVycm9yKG1lc3NhZ2UuZXJyb3IpKTtcblxuICAgIH0gZWxzZSBpZiAobWVzc2FnZS5raW5kID09ICdjaGFpblJlbW92ZWQnKSB7XG4gICAgICBwZW5kaW5nQ29uZmlybWF0aW9ucy5zaGlmdCgpO1xuXG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLmtpbmQgPT0gJ2xvZycpIHtcbiAgICAgIGxvZ0NhbGxiYWNrKG1lc3NhZ2UubGV2ZWwsIG1lc3NhZ2UudGFyZ2V0LCBtZXNzYWdlLm1lc3NhZ2UpO1xuXG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLmtpbmQgPT0gJ2xpdmVuZXNzUGluZycpIHtcbiAgICAgIHJlc2V0TGl2ZW5lc3NUaW1lb3V0KCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcignVW5rbm93biBtZXNzYWdlIHR5cGUnLCBtZXNzYWdlKTtcbiAgICB9XG4gIH0pO1xuXG4gIHdvcmtlck9uRXJyb3Iod29ya2VyLCAoZXJyb3IpID0+IHtcbiAgICAvLyBBIHdvcmtlciBlcnJvciBzaG91bGQgb25seSBoYXBwZW4gaW4gY2FzZSBvZiBhIGNyaXRpY2FsIGVycm9yIGFzIHRoZSByZXN1bHQgb2YgYSBidWdcbiAgICAvLyBzb21ld2hlcmUuIENvbnNlcXVlbnRseSwgbm90aGluZyBpcyByZWFsbHkgaW4gcGxhY2UgdG8gY2xlYW5seSByZXBvcnQgdGhlIGVycm9yLlxuICAgIGNvbnNvbGUuZXJyb3IoXG4gICAgICBcIlNtb2xkb3QgaGFzIHBhbmlja2VkLiBUaGlzIGlzIGEgYnVnIGluIHNtb2xkb3QuIFBsZWFzZSBvcGVuIGFuIGlzc3VlIGF0IFwiICtcbiAgICAgIFwiaHR0cHM6Ly9naXRodWIuY29tL3Bhcml0eXRlY2gvc21vbGRvdC9pc3N1ZXMgd2l0aCB0aGUgZm9sbG93aW5nIG1lc3NhZ2U6XCJcbiAgICApO1xuICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IpO1xuICAgIHdvcmtlckVycm9yID0gbmV3IENyYXNoRXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XG5cbiAgICAvLyBSZWplY3QgYWxsIHByb21pc2VzIHJldHVybmVkIGJ5IGBhZGRDaGFpbmAuXG4gICAgZm9yICh2YXIgcGVuZGluZyBvZiBwZW5kaW5nQ29uZmlybWF0aW9ucykge1xuICAgICAgaWYgKHBlbmRpbmcudHkgPT0gJ2NoYWluQWRkZWQnKVxuICAgICAgICBwZW5kaW5nLnJlamVjdCh3b3JrZXJFcnJvcik7XG4gICAgfVxuICAgIHBlbmRpbmdDb25maXJtYXRpb25zID0gW107XG4gIH0pO1xuXG4gIC8vIFRoZSBmaXJzdCBtZXNzYWdlIGV4cGVjdGVkIGJ5IHRoZSB3b3JrZXIgY29udGFpbnMgdGhlIGNvbmZpZ3VyYXRpb24uXG4gIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgLy8gTWF4aW11bSBsZXZlbCBvZiBsb2cgZW50cmllcyBzZW50IGJ5IHRoZSBjbGllbnQuXG4gICAgLy8gMCA9IExvZ2dpbmcgZGlzYWJsZWQsIDEgPSBFcnJvciwgMiA9IFdhcm4sIDMgPSBJbmZvLCA0ID0gRGVidWcsIDUgPSBUcmFjZVxuICAgIG1heExvZ0xldmVsOiBjb25maWcubWF4TG9nTGV2ZWwgfHwgMyxcbiAgICBmb3JiaWRUY3A6IGNvbmZpZy5mb3JiaWRUY3AsXG4gICAgZm9yYmlkV3M6IGNvbmZpZy5mb3JiaWRXcyxcbiAgICBmb3JiaWRXc3M6IGNvbmZpZy5mb3JiaWRXc3MsXG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgYWRkQ2hhaW46IChvcHRpb25zKSA9PiB7XG4gICAgICBpZiAod29ya2VyRXJyb3IpXG4gICAgICAgIHRocm93IHdvcmtlckVycm9yO1xuXG4gICAgICBsZXQgcG90ZW50aWFsUmVsYXlDaGFpbnNJZHMgPSBbXTtcbiAgICAgIGlmICghIW9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnMpIHtcbiAgICAgICAgZm9yIChjb25zdCBjaGFpbiBvZiBvcHRpb25zLnBvdGVudGlhbFJlbGF5Q2hhaW5zKSB7XG4gICAgICAgICAgLy8gVGhlIGNvbnRlbnQgb2YgYG9wdGlvbnMucG90ZW50aWFsUmVsYXlDaGFpbnNgIGFyZSBzdXBwb3NlZCB0byBiZSBjaGFpbnMgZWFybGllclxuICAgICAgICAgIC8vIHJldHVybmVkIGJ5IGBhZGRDaGFpbmAuIFRoZSBoYWNreSBgX19pbnRlcm5hbF9zbW9sZG90X2lkYCBtZXRob2QgbGV0cyB1cyBvYnRhaW4gdGhlXG4gICAgICAgICAgLy8gaW50ZXJuYWwgSUQgb2YgdGhlc2UgY2hhaW5zLlxuICAgICAgICAgIGNvbnN0IGlkID0gY2hhaW4uX19pbnRlcm5hbF9zbW9sZG90X2lkKCk7XG4gICAgICAgICAgaWYgKGlkID09PSBudWxsKSAvLyBJdCBpcyBwb3NzaWJsZSBmb3IgYGlkYCB0byBiZSBudWxsIGlmIGl0IGhhcyBlYXJsaWVyIGJlZW4gcmVtb3ZlZC5cbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIHBvdGVudGlhbFJlbGF5Q2hhaW5zSWRzLnB1c2goaWQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIEJ1aWxkIGEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgb3IgcmVqZWN0ZWQgYWZ0ZXIgdGhlIGNoYWluIGhhcyBiZWVuIGFkZGVkLlxuICAgICAgbGV0IGNoYWluQWRkZWRQcm9taXNlUmVzb2x2ZTtcbiAgICAgIGxldCBjaGFpbkFkZGVkUHJvbWlzZVJlamVjdDtcbiAgICAgIGNvbnN0IGNoYWluQWRkZWRQcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjaGFpbkFkZGVkUHJvbWlzZVJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICBjaGFpbkFkZGVkUHJvbWlzZVJlamVjdCA9IHJlamVjdDtcbiAgICAgIH0pO1xuXG4gICAgICBwZW5kaW5nQ29uZmlybWF0aW9ucy5wdXNoKHtcbiAgICAgICAgdHk6ICdjaGFpbkFkZGVkJyxcbiAgICAgICAgcmVqZWN0OiBjaGFpbkFkZGVkUHJvbWlzZVJlamVjdCxcbiAgICAgICAgcmVzb2x2ZTogY2hhaW5BZGRlZFByb21pc2VSZXNvbHZlLFxuICAgICAgICBqc29uUnBjQ2FsbGJhY2s6IG9wdGlvbnMuanNvblJwY0NhbGxiYWNrLFxuICAgICAgfSk7XG5cbiAgICAgIHdvcmtlci5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHR5OiAnYWRkQ2hhaW4nLFxuICAgICAgICBjaGFpblNwZWM6IG9wdGlvbnMuY2hhaW5TcGVjLFxuICAgICAgICBwb3RlbnRpYWxSZWxheUNoYWluczogcG90ZW50aWFsUmVsYXlDaGFpbnNJZHMsXG4gICAgICAgIGpzb25ScGNSdW5uaW5nOiAhIW9wdGlvbnMuanNvblJwY0NhbGxiYWNrLFxuICAgICAgfSk7XG5cbiAgICAgIHJldHVybiBjaGFpbkFkZGVkUHJvbWlzZTtcbiAgICB9LFxuICAgIHRlcm1pbmF0ZTogKCkgPT4ge1xuICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgaWYgKCF3b3JrZXJFcnJvcilcbiAgICAgICAgd29ya2VyRXJyb3IgPSBuZXcgQWxyZWFkeURlc3Ryb3llZEVycm9yKCk7XG4gICAgfVxuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=